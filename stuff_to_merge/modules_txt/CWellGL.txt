'=======================================================================================
'Unifloc 7.6  Vulpes zerda                                           khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
'
Option Explicit
'  класс для описания работы газлифтной скважины
'
'  предполагается, что есть пакер отделяющий затруб и газлифтные клапана
'Public NumValves As Integer
' количество газлифтных клапанов. От этого зависит количество сегментов труб
' should be read only - base on valves collection
' штуцер установленный на поверхности
Public Choke As New Cchoke
Private PipesProd As New Collection      ' коллеция труб по которым идет добыча из которых состоит скважина
Private PipesInj As New Collection       '  коллекция труб по которым идет закачка газа
Private valves As New CGLValveSet         ' коллекция клапанов установленных в скважине
'Private p_Hvalve_m() As Double              ' массив с глубинами расположения клапанов
Private p_Fluid As New CPVT                 ' fluid in well
Private p_FluidCas As New CPVT
' it is assumed - one fluid in tubing - other in casing
' in gasing gas - with additional amount of gas in flow
Private p_Qgas_inj_scm3day As Double          '
Public Trajectory As New CTrajectory     ' полная траектория скважины с инклинометрии (основной способ задания скважины)
Private p_AmbientForm As New CAmbientFormation  ' порода за пределями скважины   (new тут лишнее)
'Public Hpacker_m As Double               ' глубина установки пакера, ограничивает глубину закачки газа
Public Hvd_m As Double                   ' глубина верхних дыр перфорации
Private p_PTbuf As PTtype
Private p_PTlin As PTtype
Private p_PTcas As PTtype
Private p_PTgas_inj As PTtype
Private p_PTwf As PTtype
' параметры расчета по трубе
Private p_Param As PARAMCALC
'Public TempCorrelation As TEMP_CALC_METHOD
Private c_Curves As New Collection         ' коллекция кривых с результатами расчетов
' блок оценки качества данных
 'Private p_LogMsg As New CLogger                ' логгер
 
Public Event ReportProgress(msg As String)
Public Property Set Fluid(val As CPVT)
    Dim vlv As CGLvalve
    Dim pipe As CPipe
    ' set main tubing fluid here
    Set p_Fluid = val
    ' set clone fluid object in casing
    Set p_FluidCas = val.Clone
    
    For Each pipe In PipesProd
        Set pipe.Fluid = p_Fluid
    Next pipe
    For Each pipe In PipesInj
        Set pipe.Fluid = p_FluidCas
    Next pipe
    
    Set Choke.Fluid = p_Fluid
    Set valves.Fluid = p_Fluid
End Property
Public Property Get Fluid() As CPVT
    Set Fluid = p_Fluid
End Property
Public Property Get FluidCas() As CPVT
    Set FluidCas = p_FluidCas
End Property
Public Property Get Pwf_atma() As Double
    Pwf_atma = p_PTwf.P_atma
End Property
Public Property Let Pwf_atma(val As Double)
    p_PTwf.P_atma = val
End Property
Public Property Get Pcas_atma() As Double
    Pcas_atma = p_PTcas.P_atma
End Property
Public Property Let Pcas_atma(val As Double)
    p_PTcas.P_atma = val
End Property
Public Property Get Pgas_inj_atma() As Double
    Pgas_inj_atma = p_PTgas_inj.P_atma
End Property
Public Property Let Pgas_inj_atma(val As Double)
    p_PTgas_inj.P_atma = val
End Property
Public Property Get Tbh_C() As Double
    Tbh_C = p_PTwf.t_c
End Property
Public Property Get Pbuf_atma() As Double
    Pbuf_atma = p_PTbuf.P_atma
End Property
Public Property Let Pbuf_atma(val As Double)
    p_PTbuf.P_atma = val
End Property
Public Property Get Pline_atma() As Double
    Pline_atma = p_PTlin.P_atma
End Property
Public Property Let Pline_atma(val As Double)
    p_PTlin.P_atma = val
End Property
Public Property Get Tline_C() As Double
    Tline_C = p_PTlin.t_c
End Property
Public Property Get Tbuf_C() As Double
    Tbuf_C = p_PTbuf.t_c
End Property
Public Property Let HFlowCorrelation(val As H_CORRELATION)
    Dim prm As PARAMCALC
    prm = Param
    prm.correlation = val
    Param = prm
End Property
 
Public Property Get HFlowCorrelation() As H_CORRELATION
    HFlowCorrelation = Param.correlation
End Property
 
Public Property Let TempCorrelation(val As TEMP_CALC_METHOD)
    Dim prm As PARAMCALC
    prm = Param
    prm.tempMethod = val
    Param = prm
End Property
 
Public Property Get TempCorrelation() As TEMP_CALC_METHOD
    TempCorrelation = Param.tempMethod
End Property
Public Property Let Param(val As PARAMCALC)
    p_Param = val
    Dim pipe As CPipe
    
    For Each pipe In PipesProd
        pipe.Param = val
    Next pipe
    For Each pipe In PipesInj
        pipe.Param = val
    Next pipe
End Property
 
Public Property Get Param() As PARAMCALC
    Param = p_Param
End Property
Public Property Get Curve(Key As String) As TInterpolation
On Error Resume Next
    Dim exists As Boolean
    exists = Not IsEmpty(c_Curves.Item(Key))
    If exists Then
       Set Curve = c_Curves.Item(Key)
    Else
       Set Curve = New TInterpolation
       c_Curves.Add Curve, Key
    End If
End Property
Public Property Set Curve(Key As String, valNew As TInterpolation)
 On Error Resume Next
    Dim exists As Boolean
    exists = Not IsEmpty(c_Curves.Item(Key))
    If exists Then
       c_Curves(Key) = valNew
    Else
       c_Curves.Add valNew, Key
    End If
End Property
Public Property Get AmbientForm() As CAmbientFormation
    Set AmbientForm = p_AmbientForm
End Property
Public Property Set AmbientForm(ByVal vNewValue As CAmbientFormation)
    Dim pipe As CPipe
    Set p_AmbientForm = vNewValue
    For Each pipe In PipesProd
        Set pipe.AmbientForm = p_AmbientForm
    Next pipe
    For Each pipe In PipesInj
        Set pipe.AmbientForm = p_AmbientForm
    Next pipe
End Property
'===================================================================
'
'===================================================================
Private Sub Class_Initialize()
    With p_Param
        .correlation = AnsariCor
        .FlowDirection = FlowAgainstCoord
        .tempMethod = AmbientTemp
    End With
    p_PTcas.t_c = 30
End Sub
' метод инициализации газлифтной скважины
' должен уметь задавать все трубы по скважине из исходных данных по траектории
'
'
Public Sub InitWell(ByVal Hperf_m As Double, ByVal Htub_m As Double, ByVal Udl_m As Double, _
                    ByVal dCas_mm As Double, ByVal dTub_mm As Double, ByVal Tbh_C As Double, _
                    ByVal Twh_C As Double, _
                            Optional ByVal GLV_Hmes_m = 0, _
                            Optional ByVal GLV_dvalve_mm = 0, _
                            Optional ByVal GLV_Pbellow_atma = 0)
' метод для инициализации скважины простыми числами
On Error GoTo err1:
   Dim errMsg As String
   
   ' задаем траекторию свола скважины, на основе которого потом будет задано все остальное
   Dim tr As New CTrajectory
   Dim HabsCurve_m As New TInterpolation  ' инклинометрия - две точки
   HabsCurve_m.AddPoint 0, 0
   HabsCurve_m.AddPoint Hperf_m, Hperf_m - Udl_m
   
   Dim DcasCurve_mm As New TInterpolation  ' casing diameter
   DcasCurve_mm.AddPoint 0, dCas_mm
   DcasCurve_mm.AddPoint Hperf_m, dCas_mm  ' casing goes from top to bottom here
   
   Dim DtubCurve_mm As New TInterpolation  ' tubing diameter
   DtubCurve_mm.AddPoint 0, dTub_mm
   DtubCurve_mm.AddPoint Htub_m, dTub_mm  ' goes to tubing setting depth
   
   If IsArray(GLV_Hmes_m) Then
        Call valves.LoadFromArray(GLV_Hmes_m, GLV_dvalve_mm, GLV_Pbellow_atma)
   End If
   ' initialise trajectory (same as ESP well class)
   Call tr.InitTrajectoryHabs(HabsCurve_m, DcasCurve_mm, DtubCurve_mm, Hperf_m, Htub_m)
   Set Trajectory = tr
   Call InitWellFromTr
   
   ' save given temperature distribution
   Dim geoGrad As New TInterpolation
   geoGrad.AddPoint 0, Twh_C
   geoGrad.AddPoint Hperf_m, Tbh_C
   
   Dim ambTemp As New CAmbientFormation
   Set ambTemp.AmbTempCurve = geoGrad
   Set AmbientForm = ambTemp
   
   InitTempTr geoGrad
   Exit Sub
   
err1:
   errMsg = "CWell.InitWell: Ошибка простой инициализации скважины " & sDELIM & Err.Description
   RaiseEvent ReportProgress(errMsg)
   Err.Raise kErrInitCalc, Err.Source, errMsg
End Sub
Public Sub InitWellRangeAll(ByVal Incl_Hmes_m_ As Range, _
                           ByVal Incl_Hvert_m_ As Range, _
                           ByVal hmes_dcas_m_ As Range, _
                           ByVal dcas_arr_mm_ As Range, _
                           ByVal hmes_dtub_m_ As Range, _
                           ByVal dtub_arr_mm_ As Range, _
                           ByVal hmes_tamb_m_ As Range, _
                           ByVal tamb_C_ As Range, _
                           Optional ByVal GLV_Hmes_m_ As Range = Nothing, _
                           Optional ByVal GLV_dvalve_mm_ As Range = Nothing, _
                           Optional ByVal GLV_Pbellow_atma_ As Range = Nothing)
' метод для инициализации скважины из диапазонов измнения ключевых параметров
On Error GoTo err1:
   Dim HabsCurve_m As New TInterpolation
   Dim DcasCurve_mm As New TInterpolation
   Dim DtubCurve_mm As New TInterpolation
   Dim geoGrad As New TInterpolation
   Dim ambTemp As New CAmbientFormation
   Dim Hperf_m As Double, Htub_m As Double
   Dim errMsg As String
   
   Call HabsCurve_m.LoadFromVertRange(Incl_Hmes_m_, Incl_Hvert_m_)
   Call DcasCurve_mm.LoadFromVertRange(hmes_dcas_m_, dcas_arr_mm_)
   Call DtubCurve_mm.LoadFromVertRange(hmes_dtub_m_, dtub_arr_mm_)
   
   Call valves.LoadFromVertRange(GLV_Hmes_m_, GLV_dvalve_mm_)
'   Set valves.Fluid = Fluid
  
   Hperf_m = DcasCurve_mm.maxx
   Htub_m = DtubCurve_mm.maxx
   
   Call Trajectory.InitTrajectoryHabs(HabsCurve_m, DcasCurve_mm, DtubCurve_mm, Hperf_m, Htub_m, valves)
   Call InitWellFromTr
   
   Call geoGrad.LoadFromVertRange(hmes_tamb_m_, tamb_C_)
   Set ambTemp.AmbTempCurve = geoGrad
   
   Set AmbientForm = ambTemp
   
   InitTempTr geoGrad
   Exit Sub
err1:
   errMsg = "CWell.InitWellRangeAll: Ошибка простой инициализации скважины " & sDELIM & Err.Description
   RaiseEvent ReportProgress(errMsg)
   Err.Raise kErrInitCalc, Err.Source, errMsg
End Sub
Private Sub InitWellFromTr()
    Dim i As Integer, j As Integer
    Dim segmUp_m As Double
    Dim segmDown_m As Double
    Dim pipe As CPipe
    ' need to fill up individual pipe segments in well (production line)
    ' 1 segment from bottom hole to Htub  (lowest)
    ' next - from Htub to valve(0) depth - and so on
    ' at this point valve depth values must be ok (sorted and non zero)
        
    ' set up pipe segments for injection line
    ' 1 segment from lowest valve to upper
    ' not interested for now what happens bellow lowest valve
    
    ' set up csing flow below tubing depth
    segmDown_m = Trajectory.Hperf_m
    segmUp_m = Trajectory.Htubing_m
    If segmDown_m > segmUp_m Then
        ' first segment from bottom to tubing depth exist
        ' hae to be created here
        Set pipe = New CPipe  ' creating new object
        Set pipe.Fluid = Fluid
        Call pipe.InitPipeConstrTr(Trajectory, segmUp_m, segmDown_m, pipeCasing)
        PipesProd.Add pipe    ' save it to collection
        segmDown_m = segmUp_m
        i = valves.Count
        segmUp_m = valves.Hmes_m(i) ' will work if there is no valves set
    '    If i = 0 Then i = 1 ' if no valve - set to 1 to ensure next loop one iteration
    End If
    
    For j = i To 0 Step -1
        ' should be ok for numvalves = 0
        Set pipe = New CPipe  ' creating new object
        Set pipe.Fluid = Fluid
        Call pipe.InitPipeConstrTr(Trajectory, segmUp_m, segmDown_m, pipeTubing)
        If j < i Then
            Set pipe.GLVin = valves.valves(j + 1)
        End If
        PipesProd.Add pipe    ' save it to collection
        
        segmDown_m = segmUp_m
        segmUp_m = valves.Hmes_m(j - 1)
        If segmUp_m < segmDown_m Then
            ' if exist segment
            Set pipe = New CPipe  ' creating new object
            Set pipe.Fluid = Fluid
            Call pipe.InitPipeConstrTr(Trajectory, segmUp_m, segmDown_m, pipeAnnulus)
            Set pipe.GLVin = valves.valves(j)
            PipesInj.Add pipe
        End If
        
        
    Next j
'   Hvd_m = Trajectory.Htubing_m ' определим глубину спуска установки
'   p_Hspvert_m = Trajectory.HabsZ_m(p_Hsp_m)    ' в том числе по вертикали
'   Call p_Pipe_HspHvd.InitPipeConstrTr(Trajectory, Trajectory.Htubing_m, Trajectory.Hperf_m, 1)
    Choke.Dup_m = 0.06
    Choke.Ddown_m = 0.06
    For Each pipe In PipesProd
        Set pipe.AmbientForm = AmbientForm
    Next pipe
    For Each pipe In PipesInj
        Set pipe.AmbientForm = AmbientForm
    Next pipe
    
    Hvd_m = Trajectory.Hperf_m
  ' переводим в состояние "целостность нарушена"
'   p_Calculated = False
End Sub
 Public Sub InitTempTr(geoGrad As TInterpolation)
' процедура для инициализации температуры в скважине, для линейнго расчета
' при линейном расчете предполагается,
' что температура меняется линейно относительно глубины скважины
'
   Dim TempGradVert As Double
   Dim pipe As CPipe
   p_PTwf.t_c = geoGrad.GetPoint(geoGrad.maxx)
   p_PTbuf.t_c = geoGrad.GetPoint(geoGrad.minx)
   
   TempGradVert = (p_PTwf.t_c - p_PTbuf.t_c) / Hvd_m
      
   For Each pipe In PipesProd
       pipe.dTdLinit = TempGradVert
   Next pipe
   For Each pipe In PipesInj
       pipe.dTdLinit = TempGradVert
   Next pipe
   
   TempCorrelation = GeoGradTemp
End Sub
 
Public Sub InitTempLinear(ByVal Tbhinit_C As Double, ByVal Twhinit_C As Double)
' процедура для инициализации температуры в скважине, для линейнго расчета
   Dim TempGrad As Double
   Dim i As Integer
   Dim tempDown_C As Double
   Dim tempUp_C As Double
   Dim pipe As CPipe
   Dim HvalveVert0_m  As Double
   
   TempGrad = (Tbhinit_C - Twhinit_C) / Hvd_m
   p_PTwf.t_c = Tbhinit_C
   p_PTbuf.t_c = Twhinit_C
   
   tempUp_C = Tbhinit_C
   For i = 1 To PipesProd.Count
        Set pipe = PipesProd(i)
        tempDown_C = tempUp_C
        tempUp_C = tempDown_C - TempGrad * pipe.LengthMes_m
        pipe.InitTlinear tempUp_C, tempDown_C
   Next i
   
   HvalveVert0_m = Trajectory.HabsZ_m(valves.Hmes_lowest_m)
   tempUp_C = AmbientForm.AmbTemp_С(HvalveVert0_m)
   For i = 1 To PipesInj.Count
        Set pipe = PipesInj(i)
        tempDown_C = tempUp_C
        tempUp_C = tempDown_C - TempGrad * pipe.LengthMes_m
        pipe.InitTlinear tempUp_C, tempDown_C
   Next i
   
   TempCorrelation = StartEndTemp
   
End Sub
Public Function Calc_Plin_Pwf_atma_(PTwf As PTtype, _
                                    Optional ByVal Pcas_inj_atma As Double = 1, _
                                    Optional ByVal Qgas_inj_scm3day As Double = -1, _
                                    Optional ByVal CalcChoke As Boolean = True, _
                                    Optional ByVal saveCurve As CALC_RESULTS = noCurves) As Double
' @brief расчет давления на устье через забойное давление (снизу -> вверх)
' @param Pwf - исходное забойное давление и температура
' @Qgas_inj_scm3day - gas rate injected. If given - used at deepest GLV
' @CalcCasing - флаг показывает надо ли считать ветку распределения давления по забтрубу - динамический уровень и затрубное давление
' @CalcChoke - показывает надо ли считать штуцер
' @saveCurve - показывает насколько детально надо сохранять результаты расчета
Dim Tintake_esp_C As Double
Dim PT_temp As PTtype
Dim PTcas_temp As PTtype
Dim Tan_C As Double
Dim pcur As TInterpolation
Dim i As Integer
Dim pipe As CPipe
Dim Qgfree_tot_scm3day As Double
Qgfree_tot_scm3day = 0
Dim Fluid_Pipe_Below As CPVT
' first initialize temp fluid with general one
Set Fluid_Pipe_Below = Fluid
' flag show if lowest GLV has been acounted
Dim LowestGLVdone As Boolean
LowestGLVdone = False
Dim Qgas_inj_GLV_scm3day As Double
Qgas_inj_GLV_scm3day = 0
    
On Error GoTo err1:
    ' 1. Start calculation from Pwf, Tbh
    p_PTwf = PTwf
    PT_temp = PTwf
    PTcas_temp = SetPT(Pcas_inj_atma, p_PTcas.t_c)
    
    ' 2. calculate pressure distribution in annulus
    
    For i = PipesInj.Count To 1 Step -1
        Set pipe = PipesInj(i)
        pipe.Param = ParamCalcFromTop(Gas, TempCorrelation)
        PTcas_temp = pipe.Calc_dPipe(PTcas_temp, saveCurve)
        If Not pipe.GLVin Is Nothing Then
            ' if  there is a valve - save PT in casing at valve intake
            pipe.GLVin.Pin_atma = PTcas_temp.P_atma
            pipe.GLVin.Tin_C = PTcas_temp.t_c
        End If
    Next i
    
    ' 3. calc tubing pressure
    For i = 1 To PipesProd.Count
        ' first segment - from bottom to tubing depth then goes up
        Set pipe = PipesProd(i)
        ' taking fluid from previos segment - if we had gas injected below it will acounted here
        Set pipe.Fluid = Fluid_Pipe_Below
        ' check if there is a valve on pipe bottom
        ' GLV meant it is possible ijection point
        If Not pipe.GLVin Is Nothing Then
            ' if valve set up then estimate gas coming through valve
            pipe.GLVin.Pout_atma = PT_temp.P_atma   ' pressure at pipe bottom from previos step
            pipe.GLVin.Tout_C = PT_temp.t_c
            ' adding additional gas coming trough valve
On Error GoTo err2:
            If Qgas_inj_scm3day > 0 Then
                ' use manual Qgas in well
                If Not LowestGLVdone Then
                    Qgas_inj_GLV_scm3day = Qgas_inj_scm3day
                    LowestGLVdone = True
                Else
                    Qgas_inj_GLV_scm3day = 0
                End If
            Else
                Qgas_inj_GLV_scm3day = pipe.GLVin.calc_Qgas_scm3day(-1, -1, -1)
                i = i / 0
            End If
            pipe.GLVin.Qgas_inj_scm3day = Qgas_inj_GLV_scm3day
On Error GoTo err1:
            Qgfree_tot_scm3day = Qgfree_tot_scm3day + Qgas_inj_GLV_scm3day
            If Qgas_inj_GLV_scm3day > 0 Then
                Set pipe.Fluid = Fluid_Pipe_Below.Clone
                pipe.Fluid.Qgfree_scm3day = Qgfree_tot_scm3day
                Set Fluid_Pipe_Below = pipe.Fluid
            End If
        End If
     
        pipe.Param = ParamCalcFromBottom(HFlowCorrelation, TempCorrelation)
        PT_temp = pipe.Calc_dPipe(PT_temp, saveCurve)
    Next i
    p_PTbuf = PT_temp
    p_PTlin = p_PTbuf
On Error GoTo err3:
    ' 4. Расчет линейного давления по штуцеру
    If Choke.Dchoke_m > 0 And CalcChoke Then     ' пока отключено
        Set Choke.Fluid = pipe.Fluid   ' take fluid from last pipe
        p_PTlin = Choke.Calc_Choke_Plin(p_PTbuf)
        If p_PTlin.P_atma < 0 Then
            p_PTlin.P_atma = 1
        End If
    End If
On Error GoTo err1:
    Calc_Plin_Pwf_atma_ = PT_temp.P_atma
    
    If saveCurve > 0 Then
        For i = 1 To PipesProd.Count
            Call Curve(str_PtubHmes_curve).AddPointsCurve(PipesProd(i).PCurve)
            Call Curve(str_TtubHmes_curve).AddPointsCurve(PipesProd(i).TCurve)
            Call Curve(str_TambHmes_curve).AddPointsCurve(PipesProd(i).TambCurve)
            If saveCurve > 1 Then
                Call Curve(str_HlHmes_curve).AddPointsCurve(PipesProd(i).HlCurve)
                Curve(str_HlHmes_curve).yName = "Hl"
            End If
        Next i
        For i = 1 To PipesInj.Count
           Call Curve(str_PcasHmes_curve).AddPointsCurve(PipesInj(i).PCurve)
           Call Curve(str_TcasHmes_curve).AddPointsCurve(PipesInj(i).TCurve)
        Next i
        
        Curve(str_PtubHmes_curve).xName = "hmes ptub"
        Curve(str_PtubHmes_curve).yName = "Ptub"
        
        Curve(str_TtubHmes_curve).xName = "hmes Ttub"
        Curve(str_TtubHmes_curve).yName = "Ttub"
        
        Curve(str_TambHmes_curve).xName = "hmes Tamb"
        Curve(str_TambHmes_curve).yName = "Tamb"
        
        Curve(str_PcasHmes_curve).xName = "hmes pcas"
        Curve(str_PcasHmes_curve).yName = "pcas"
        
        Curve(str_TcasHmes_curve).xName = "hmes pcas"
        Curve(str_TcasHmes_curve).yName = "Tcas"
    End If
    Exit Function
err1:
    On Error Resume Next
    RaiseEvent ReportProgress("CWellGL.Calc_Plin_Pwf_atma: some general error")
    Err.Raise Err.Number, Err.Source, Err.Description
    Exit Function
err2:
    On Error Resume Next
    addLogMsg "CWellGL.Calc_Plin_Pwf_atma:error while GLV Hmes = " & CStr(pipe.GLVin.Hmes_m) & " calc - Qgas_inj_GLV_scm3day = " & CStr(Qgas_inj_GLV_scm3day)
    Resume Next
    Exit Function
err3:
    On Error Resume Next
    addLogMsg "CWellGL.Calc_Plin_Pwf_atma:error while choke calc - choke have been  ignored"
    Resume Next
End Function
Public Function Calc_Pwf_Plin_atma(ByVal Plin_atma As Double, _
                                    ByVal Tbh_C As Double, _
                                    Optional Pcas_inj_atma As Double = 1, _
                                    Optional Qgas_inj_scm3day As Double = 0, _
                                    Optional ByVal CalcChoke As Boolean = True, _
                                    Optional saveCurve As CALC_RESULTS = noCurves)
' @brief Calc_Pwf_Plin_atma расчет забойного давления по известному давлению в линии и конструкции скважины дихотомией
' @param Plin_atma - давление в линии
' @param Hd - динамический уровень
' @param Tbh_C - температура на забое скважины
' @return Подсчитанное для заданного линейного давление
On Error GoTo err1:
    Dim Pwf1 As Double      ' первое приближение
    Dim PwfUp As Double, PwfDown As Double
    Dim PlinUp As Double, PlinDown As Double
    Dim Plin0 As Double, Plin1 As Double
    Dim found_solution As Boolean
    Dim i As Integer
    found_solution = False
    i = 0
    Pwf1 = 60
    PwfUp = -1
    PwfDown = -1
    Do
        ' ищем  приближения
        Plin1 = Calc_Plin_Pwf_atma_(SetPT(Pwf1, Tbh_C), Pcas_inj_atma, Qgas_inj_scm3day, saveCurve:=noCurves)
        If (Abs(Plin1 - Plin_atma) < const_well_P_tolerance) Then
             found_solution = True
             p_PTwf.P_atma = Pwf1
             p_PTwf.t_c = Tbh_C
        End If
        If Not found_solution Then
          If Plin1 > Plin_atma Then
              PwfUp = Pwf1
              PlinUp = Plin1
              If PwfDown < 0 Then
                  Pwf1 = PwfUp / 2
              Else
                  Pwf1 = PwfDown + (PwfUp - PwfDown) * (Plin_atma - PlinDown) / (PlinUp - PlinDown)
              End If
          Else
              PwfDown = Pwf1
              PlinDown = Plin1
              If PwfUp < 0 Then
                  Pwf1 = Pwf1 * 2
              Else
                  Pwf1 = (PwfUp + PwfDown) / 2
              End If
          End If
        End If
        i = i + 1
    Loop While Not found_solution And i < 20
    
    If i = 20 Then
       addLogMsg "CWellGL.Calc_Pwf_Plin_atma: max iteration num reached. i = " & CStr(i) & " tolerance reached = " & CStr(Abs(Plin1 - Plin_atma))
    End If
    
    p_PTlin = SetPT(Calc_Plin_Pwf_atma_(p_PTwf, Pcas_inj_atma, Qgas_inj_scm3day, saveCurve:=saveCurve), Tbuf_C)
    
    If Abs(Pline_atma - Plin_atma) > const_well_P_tolerance Then
       addLogMsg "CWellGL.Calc_Pwf_Plin_atma: BHP estimation error exceeds tolerance " & const_well_P_tolerance & ". Equal = " & Abs(Me.Pline_atma - Plin_atma)
    End If
    Calc_Pwf_Plin_atma = p_PTwf.P_atma
    
    Exit Function
err1:
    ' тут надо среагировать на ошибку
        On Error Resume Next
    RaiseEvent ReportProgress("CWellGL.Calc_Plin_Pwf_atma: some general error")
    Err.Raise Err.Number, Err.Source, Err.Description
    Exit Function
 End Function

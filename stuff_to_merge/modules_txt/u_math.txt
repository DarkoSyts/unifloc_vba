'=======================================================================================
'Unifloc 7.6  Vulpes zerda                                           khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
' математические расчеты
'
'
'
'
Option Explicit
Public Const MachineEpsilon = 5E-16
Public Const MaxRealNumber = 1E+300
Public Const MinRealNumber = 1E-300
Private Const BigNumber As Double = 1E+70
Private Const SmallNumber As Double = 1E-70
Public Type Complex
    X As Double
    y As Double
End Type
'Data types
Public Type RCommState
    Stage As Long
    BA() As Boolean
    IA() As Long
    RA() As Double
    CA() As Complex
End Type
Public Type ALGLIBDataset
    NIn As Long
    NOut As Long
    NClasses As Long
    
    Trn() As Double
    Tst() As Double
    val() As Double
    AllDataset() As Double
    
    TrnSize As Long
    TstSize As Long
    ValSize As Long
    TotalSize As Long
End Type
Public Type ODESolverState
    N As Long
    M As Long
    XScale As Double
    H As Double
    eps As Double
    FracEps As Boolean
    YC() As Double
    EScale() As Double
    XG() As Double
    SolverType As Long
    X As Double
    y() As Double
    DY() As Double
    YTbl() As Double
    RepTerminationType As Long
    RepNFEV As Long
    YN() As Double
    YNS() As Double
    RKA() As Double
    RKC() As Double
    RKCS() As Double
    RKB() As Double
    RKK() As Double
    RState As RCommState
End Type
Public Type ODESolverReport
    NFEV As Long
    TerminationType As Long
End Type
'Global constants
Private Const ODESolverMaxGrow As Double = 3#
Private Const ODESolverMaxShrink As Double = 10#
Function tand(ang) As Double
 tand = Tan(ang / 180 * const_Pi)
End Function
Function cosd(ang) As Double
 cosd = Cos(ang / 180 * const_Pi)
End Function
Function sind(ang) As Double
 sind = Sin(ang / 180 * const_Pi)
End Function
Public Function min(a As Double, b As Double) As Double
  If a < b Then min = a Else min = b
End Function
Public Function max(a As Double, b As Double) As Double
  If a > b Then max = a Else max = b
End Function
Public Function log10(X As Double) As Double
 log10 = Log(X) / Log(10#)
End Function
Public Function isEqual(a As Double, b As Double) As Double
    Const eps = const_P_difference
    isEqual = False
    If Abs(a - b) < eps Then isEqual = True
End Function
Public Function isGreater(a As Double, b As Double) As Double
    Const eps = const_P_difference
    isGreater = False
    If (a - b) > eps Then isGreater = True
End Function
 
Public Function isBetween(a As Double, a0 As Double, a1 As Double)
    isBetween = False
    If ((a <= a0) And (a >= a1)) Or ((a >= a0) And (a <= a1)) Then isBetween = True
End Function
 
Public Function ArcCos(ByVal X As Double) As Double
    Dim t As Double
    t = Sqr(1 - X * X)
    If t < SmallNumber Then
        ArcCos = Atn(BigNumber * Sgn(-X)) + 2 * Atn(1)
    Else
        ArcCos = Atn(-X / t) + 2 * Atn(1)
    End If
End Function
 
Public Function ArcSin(ByVal X As Double) As Double
    Dim t As Double
    t = Sqr(1 - X * X)
    If t < SmallNumber Then
        ArcSin = Atn(BigNumber * Sgn(X))
    Else
        ArcSin = Atn(X / t)
    End If
End Function
 
Public Function ArcTan(X As Double) As Double
  'Inverse Tangent
    On Error Resume Next
        ArcTan = Atn(X) '* (180 / PI)
    On Error GoTo 0
End Function
Public Function MaxReal(ByVal M1 As Double, ByVal M2 As Double) As Double
    If M1 > M2 Then
        MaxReal = M1
    Else
        MaxReal = M2
    End If
End Function
Public Function MinReal(ByVal M1 As Double, ByVal M2 As Double) As Double
    If M1 < M2 Then
        MinReal = M1
    Else
        MinReal = M2
    End If
End Function
Public Function MaxInt(ByVal M1 As Long, ByVal M2 As Long) As Long
    If M1 > M2 Then
        MaxInt = M1
    Else
        MaxInt = M2
    End If
End Function
Public Function MinInt(ByVal M1 As Long, ByVal M2 As Long) As Long
    If M1 < M2 Then
        MinInt = M1
    Else
        MinInt = M2
    End If
End Function
Public Function SinH(ByVal X As Double) As Double
    SinH = (Exp(X) - Exp(-X)) / 2
End Function
Public Function CosH(ByVal X As Double) As Double
    CosH = (Exp(X) + Exp(-X)) / 2
End Function
Public Function TanH(ByVal X As Double) As Double
    Dim t As Double
    If X > 0 Then
        t = Exp(-X)
        t = t * t
        TanH = (1 - t) / (1 + t)
    Else
        t = Exp(X)
        t = t * t
        TanH = (t - 1) / (t + 1)
    End If
End Function
Public Function Power(ByVal Base As Double, ByVal Exponent As Double) As Double
    Power = Base ^ Exponent
End Function
Public Function Square(ByVal X As Double) As Double
    Square = X * X
End Function
Public Function Ceil(ByVal X As Double) As Double
    Ceil = -Int(-X)
End Function
Public Function RandomInteger(ByVal X As Long) As Long
    RandomInteger = Int(Rnd() * X)
End Function
Public Function Atn2(ByVal y As Double, ByVal X As Double) As Double
    If SmallNumber * Abs(y) < Abs(X) Then
        If X < 0 Then
            If y = 0 Then
                Atn2 = const_Pi
            Else
                Atn2 = Atn(y / X) + const_Pi * Sgn(y)
            End If
        Else
            Atn2 = Atn(y / X)
        End If
    Else
        Atn2 = Sgn(y) * const_Pi / 2
    End If
End Function
' ===========================================================================================
'  math_complex
' ===========================================================================================
'=======================================================================================
'Unifloc 7.6  Vulpes zerda                                           khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
Public Function C_Complex(ByVal X As Double) As Complex
    Dim result As Complex
    result.X = X
    result.y = 0
    C_Complex = result
End Function
Public Function AbsComplex(ByRef z As Complex) As Double
    Dim result As Double
    Dim W As Double
    Dim XABS As Double
    Dim YABS As Double
    Dim v As Double
    XABS = Abs(z.X)
    YABS = Abs(z.y)
    W = MaxReal(XABS, YABS)
    v = MinReal(XABS, YABS)
    If v = 0 Then
        result = W
    Else
        result = W * Sqr(1 + Square(v / W))
    End If
    AbsComplex = result
End Function
Public Function C_Opposite(ByRef z As Complex) As Complex
    Dim result As Complex
    result.X = -z.X
    result.y = -z.y
    C_Opposite = result
End Function
Public Function Conj(ByRef z As Complex) As Complex
    Dim result As Complex
    result.X = z.X
    result.y = -z.y
    Conj = result
End Function
Public Function CSqr(ByRef z As Complex) As Complex
    Dim result As Complex
    result.X = Square(z.X) - Square(z.y)
    result.y = 2 * z.X * z.y
    CSqr = result
End Function
Public Function C_Add(ByRef z1 As Complex, ByRef z2 As Complex) As Complex
    Dim result As Complex
    result.X = z1.X + z2.X
    result.y = z1.y + z2.y
    C_Add = result
End Function
Public Function C_Mul(ByRef z1 As Complex, ByRef z2 As Complex) As Complex
    Dim result As Complex
    result.X = z1.X * z2.X - z1.y * z2.y
    result.y = z1.X * z2.y + z1.y * z2.X
    C_Mul = result
End Function
Public Function C_AddR(ByRef z1 As Complex, ByVal R As Double) As Complex
    Dim result As Complex
    result.X = z1.X + R
    result.y = z1.y
    C_AddR = result
End Function
Public Function C_MulR(ByRef z1 As Complex, ByVal R As Double) As Complex
    Dim result As Complex
    result.X = z1.X * R
    result.y = z1.y * R
    C_MulR = result
End Function
Public Function C_Sub(ByRef z1 As Complex, ByRef z2 As Complex) As Complex
    Dim result As Complex
    result.X = z1.X - z2.X
    result.y = z1.y - z2.y
    C_Sub = result
End Function
Public Function C_SubR(ByRef z1 As Complex, ByVal R As Double) As Complex
    Dim result As Complex
    result.X = z1.X - R
    result.y = z1.y
    C_SubR = result
End Function
Public Function C_RSub(ByVal R As Double, ByRef z1 As Complex) As Complex
    Dim result As Complex
    result.X = R - z1.X
    result.y = -z1.y
    C_RSub = result
End Function
Public Function C_Div(ByRef z1 As Complex, ByRef z2 As Complex) As Complex
    Dim result As Complex
    Dim a As Double
    Dim b As Double
    Dim c As Double
    Dim d As Double
    Dim E As Double
    Dim f As Double
    a = z1.X
    b = z1.y
    c = z2.X
    d = z2.y
    If Abs(d) < Abs(c) Then
        E = d / c
        f = c + d * E
        result.X = (a + b * E) / f
        result.y = (b - a * E) / f
    Else
        E = c / d
        f = d + c * E
        result.X = (b + a * E) / f
        result.y = (-a + b * E) / f
    End If
    C_Div = result
End Function
Public Function C_DivR(ByRef z1 As Complex, ByVal R As Double) As Complex
    Dim result As Complex
    result.X = z1.X / R
    result.y = z1.y / R
    C_DivR = result
End Function
Public Function C_RDiv(ByVal R As Double, ByRef z2 As Complex) As Complex
    Dim result As Complex
    Dim a As Double
    Dim c As Double
    Dim d As Double
    Dim E As Double
    Dim f As Double
    a = R
    c = z2.X
    d = z2.y
    If Abs(d) < Abs(c) Then
        E = d / c
        f = c + d * E
        result.X = a / f
        result.y = -(a * E / f)
    Else
        E = c / d
        f = d + c * E
        result.X = a * E / f
        result.y = -(a / f)
    End If
    C_RDiv = result
End Function
Public Function C_Equal(ByRef z1 As Complex, ByRef z2 As Complex) As Boolean
    Dim result As Boolean
    result = z1.X = z2.X And z1.y = z2.y
    C_Equal = result
End Function
Public Function C_NotEqual(ByRef z1 As Complex, _
         ByRef z2 As Complex) As Boolean
    Dim result As Boolean
    result = z1.X <> z2.X Or z1.y <> z2.y
    C_NotEqual = result
End Function
Public Function C_EqualR(ByRef z1 As Complex, ByVal R As Double) As Boolean
    Dim result As Boolean
    result = z1.X = R And z1.y = 0
    C_EqualR = result
End Function
Public Function C_NotEqualR(ByRef z1 As Complex, _
         ByVal R As Double) As Boolean
    Dim result As Boolean
    result = z1.X <> R Or z1.y <> 0
    C_NotEqualR = result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Copyright 2009 by Sergey Bochkanov (ALGLIB project).
'
'>>> SOURCE LICENSE >>>
'This program is free software; you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation (www.fsf.org); either version 2 of the
'License, or (at your option) any later version.
'
'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.
'
'A copy of the GNU General Public License is available at
'http://www.fsf.org/licensing/licenses
'
'>>> END OF LICENSE >>>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Cash-Karp adaptive ODE solver.
'
'This subroutine solves ODE  Y'=f(Y,x)  with  initial  conditions  Y(xs)=Ys
'(here Y may be single variable or vector of N variables).
'
'INPUT PARAMETERS:
'    Y       -   initial conditions, array[0..N-1].
'                contains values of Y[] at X[0]
'    N       -   system size
'    X       -   points at which Y should be tabulated, array[0..M-1]
'                integrations starts at X[0], ends at X[M-1],  intermediate
'                values at X[i] are returned too.
'                SHOULD BE ORDERED BY ASCENDING OR BY DESCENDING!!!!
'    M       -   number of intermediate points + first point + last point:
'                * M>2 means that you need both Y(X[M-1]) and M-2 values at
'                  intermediate points
'                * M=2 means that you want just to integrate from  X[0]  to
'                  X[1] and don't interested in intermediate values.
'                * M=1 means that you don't want to integrate :)
'                  it is degenerate case, but it will be handled correctly.
'                * M<1 means error
'    Eps     -   tolerance (absolute/relative error on each  step  will  be
'                less than Eps). When passing:
'                * Eps>0, it means desired ABSOLUTE error
'                * Eps<0, it means desired RELATIVE error.  Relative errors
'                  are calculated with respect to maximum values of  Y seen
'                  so far. Be careful to use this criterion  when  starting
'                  from Y[] that are close to zero.
'    H       -   initial  step  lenth,  it  will  be adjusted automatically
'                after the first  step.  If  H=0,  step  will  be  selected
'                automatically  (usualy  it  will  be  equal  to  0.001  of
'                min(x[i]-x[j])).
'
'OUTPUT PARAMETERS
'    State   -   structure which stores algorithm state between  subsequent
'                calls of OdeSolverIteration. Used for reverse communication.
'                This structure should be passed  to the OdeSolverIteration
'                subroutine.
'
'SEE ALSO
'    AutoGKSmoothW, AutoGKSingular, AutoGKIteration, AutoGKResults.
'
'
'  -- ALGLIB --
'     Copyright 01.09.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ODESolverRKCK(ByRef y() As Double, _
         ByVal N As Long, _
         ByRef X() As Double, _
         ByVal M As Long, _
         ByVal eps As Double, _
         ByVal H As Double, _
         ByRef state As ODESolverState)
    Call ODESolverInit(0#, y, N, X, M, eps, H, state)
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'One iteration of ODE solver.
'
'Called after inialization of State structure with OdeSolverXXX subroutine.
'See HTML docs for examples.
'
'INPUT PARAMETERS:
'    State   -   structure which stores algorithm state between subsequent
'                calls and which is used for reverse communication. Must be
'                initialized with OdeSolverXXX() call first.
'
'If subroutine returned False, algorithm have finished its work.
'If subroutine returned True, then user should:
'* calculate F(State.X, State.Y)
'* store it in State.DY
'Here State.X is real, State.Y and State.DY are arrays[0..N-1] of reals.
'
'  -- ALGLIB --
'     Copyright 01.09.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function ODESolverIteration(ByRef state As ODESolverState) As Boolean
    Dim result As Boolean
    Dim N As Long
    Dim M As Long
    Dim i As Long
    Dim j As Long
    Dim k As Long
    Dim XC As Double
    Dim v As Double
    Dim H As Double
    Dim H2 As Double
    Dim GridPoint As Boolean
    Dim Err As Double
    Dim MaxGrowPow As Double
    Dim KLimit As Long
    Dim i_ As Long
    
    '
    ' Reverse communication preparations
    ' I know it looks ugly, but it works the same way
    ' anywhere from C++ to Python.
    '
    ' This code initializes locals by:
    ' * random values determined during code
    '   generation - on first subroutine call
    ' * values from previous call - on subsequent calls
    '
    If state.RState.Stage >= 0# Then
        N = state.RState.IA(0#)
        M = state.RState.IA(1#)
        i = state.RState.IA(2#)
        j = state.RState.IA(3#)
        k = state.RState.IA(4#)
        KLimit = state.RState.IA(5#)
        GridPoint = state.RState.BA(0#)
        XC = state.RState.RA(0#)
        v = state.RState.RA(1#)
        H = state.RState.RA(2#)
        H2 = state.RState.RA(3#)
        Err = state.RState.RA(4#)
        MaxGrowPow = state.RState.RA(5#)
    Else
        N = -983#
        M = -989#
        i = -834#
        j = 900#
        k = -287#
        KLimit = 364#
        GridPoint = False
        XC = -338#
        v = -686#
        H = 912#
        H2 = 585#
        Err = 497#
        MaxGrowPow = -271#
    End If
    If state.RState.Stage = 0# Then
        GoTo lbl_0
    End If
    
    '
    ' Routine body
    '
    
    '
    ' prepare
    '
    If state.RepTerminationType <> 0# Then
        result = False
        ODESolverIteration = result
        Exit Function
    End If
    N = state.N
    M = state.M
    H = state.H
    ReDim state.y(0 To N - 1)
    ReDim state.DY(0 To N - 1)
    MaxGrowPow = Power(ODESolverMaxGrow, 5#)
    state.RepNFEV = 0#
    
    '
    ' some preliminary checks for internal errors
    ' after this we assume that H>0 and M>1
    '
    
    '
    ' choose solver
    '
    If state.SolverType <> 0# Then
        GoTo lbl_1
    End If
    
    '
    ' Cask-Karp solver
    ' Prepare coefficients table.
    ' Check it for errors
    '
    ReDim state.RKA(0 To 6# - 1)
    state.RKA(0#) = 0#
    state.RKA(1#) = 1# / 5#
    state.RKA(2#) = 3# / 10#
    state.RKA(3#) = 3# / 5#
    state.RKA(4#) = 1#
    state.RKA(5#) = 7# / 8#
    ReDim state.RKB(0 To 6# - 1, 0 To 5# - 1)
    state.RKB(1#, 0#) = 1# / 5#
    state.RKB(2#, 0#) = 3# / 40#
    state.RKB(2#, 1#) = 9# / 40#
    state.RKB(3#, 0#) = 3# / 10#
    state.RKB(3#, 1#) = -(9# / 10#)
    state.RKB(3#, 2#) = 6# / 5#
    state.RKB(4#, 0#) = -(11# / 54#)
    state.RKB(4#, 1#) = 5# / 2#
    state.RKB(4#, 2#) = -(70# / 27#)
    state.RKB(4#, 3#) = 35# / 27#
    state.RKB(5#, 0#) = 1631# / 55296#
    state.RKB(5#, 1#) = 175# / 512#
    state.RKB(5#, 2#) = 575# / 13824#
    state.RKB(5#, 3#) = 44275# / 110592#
    state.RKB(5#, 4#) = 253# / 4096#
    ReDim state.RKC(0 To 6# - 1)
    state.RKC(0#) = 37# / 378#
    state.RKC(1#) = 0#
    state.RKC(2#) = 250# / 621#
    state.RKC(3#) = 125# / 594#
    state.RKC(4#) = 0#
    state.RKC(5#) = 512# / 1771#
    ReDim state.RKCS(0 To 6# - 1)
    state.RKCS(0#) = 2825# / 27648#
    state.RKCS(1#) = 0#
    state.RKCS(2#) = 18575# / 48384#
    state.RKCS(3#) = 13525# / 55296#
    state.RKCS(4#) = 277# / 14336#
    state.RKCS(5#) = 1# / 4#
    ReDim state.RKK(0 To 6# - 1, 0 To N - 1)
    
    '
    ' Main cycle consists of two iterations:
    ' * outer where we travel from X[i-1] to X[i]
    ' * inner where we travel inside [X[i-1],X[i]]
    '
    ReDim state.YTbl(0 To M - 1, 0 To N - 1)
    ReDim state.EScale(0 To N - 1)
    ReDim state.YN(0 To N - 1)
    ReDim state.YNS(0 To N - 1)
    XC = state.XG(0#)
    For i_ = 0# To N - 1# Step 1
        state.YTbl(0#, i_) = state.YC(i_)
    Next i_
    For j = 0# To N - 1# Step 1
        state.EScale(j) = 0#
    Next j
    i = 1#
lbl_3:
    If i > M - 1# Then
        GoTo lbl_5
    End If
    
    '
    ' begin inner iteration
    '
lbl_6:
    If False Then
        GoTo lbl_7
    End If
    
    '
    ' truncate step if needed (beyond right boundary).
    ' determine should we store X or not
    '
    If XC + H >= state.XG(i) Then
        H = state.XG(i) - XC
        GridPoint = True
    Else
        GridPoint = False
    End If
    
    '
    ' Update error scale maximums
    '
    ' These maximums are initialized by zeros,
    ' then updated every iterations.
    '
    For j = 0# To N - 1# Step 1
        state.EScale(j) = MaxReal(state.EScale(j), Abs(state.YC(j)))
    Next j
    
    '
    ' make one step:
    ' 1. calculate all info needed to do step
    ' 2. update errors scale maximums using values/derivatives
    '    obtained during (1)
    '
    ' Take into account that we use scaling of X to reduce task
    ' to the form where x[0] < x[1] < ... < x[n-1]. So X is
    ' replaced by x=xscale*t, and dy/dx=f(y,x) is replaced
    ' by dy/dt=xscale*f(y,xscale*t).
    '
    For i_ = 0# To N - 1# Step 1
        state.YN(i_) = state.YC(i_)
    Next i_
    For i_ = 0# To N - 1# Step 1
        state.YNS(i_) = state.YC(i_)
    Next i_
    k = 0#
lbl_8:
    If k > 5# Then
        GoTo lbl_10
    End If
    
    '
    ' prepare data for the next update of YN/YNS
    '
    state.X = state.XScale * (XC + state.RKA(k) * H)
    For i_ = 0# To N - 1# Step 1
        state.y(i_) = state.YC(i_)
    Next i_
    For j = 0# To k - 1# Step 1
        v = state.RKB(k, j)
        For i_ = 0# To N - 1# Step 1
            state.y(i_) = state.y(i_) + v * state.RKK(j, i_)
        Next i_
    Next j
    state.RState.Stage = 0#
    GoTo lbl_rcomm
lbl_0:
    state.RepNFEV = state.RepNFEV + 1#
    v = H * state.XScale
    For i_ = 0# To N - 1# Step 1
        state.RKK(k, i_) = v * state.DY(i_)
    Next i_
    
    '
    ' update YN/YNS
    '
    v = state.RKC(k)
    For i_ = 0# To N - 1# Step 1
        state.YN(i_) = state.YN(i_) + v * state.RKK(k, i_)
    Next i_
    v = state.RKCS(k)
    For i_ = 0# To N - 1# Step 1
        state.YNS(i_) = state.YNS(i_) + v * state.RKK(k, i_)
    Next i_
    k = k + 1#
    GoTo lbl_8
lbl_10:
    
    '
    ' estimate error
    '
    Err = 0#
    For j = 0# To N - 1# Step 1
        If Not state.FracEps Then
            
            '
            ' absolute error is estimated
            '
            Err = MaxReal(Err, Abs(state.YN(j) - state.YNS(j)))
        Else
            
            '
            ' Relative error is estimated
            '
            v = state.EScale(j)
            If v = 0# Then
                v = 1#
            End If
            Err = MaxReal(Err, Abs(state.YN(j) - state.YNS(j)) / v)
        End If
    Next j
    
    '
    ' calculate new step, restart if necessary
    '
    If MaxGrowPow * Err <= state.eps Then
        H2 = ODESolverMaxGrow * H
    Else
        H2 = H * Power(state.eps / Err, 0.2)
    End If
    If H2 < H / ODESolverMaxShrink Then
        H2 = H / ODESolverMaxShrink
    End If
    If Err > state.eps Then
        H = H2
        GoTo lbl_6
    End If
    
  '  If H > 10 Then H = 10
    '
    ' advance position
    '
    XC = XC + H
    For i_ = 0# To N - 1# Step 1
        state.YC(i_) = state.YN(i_)
    Next i_
    
    '
    ' update H
    '
    H = H2
    
   '   If H > 10 Then H = 10
  
    '
    ' break on grid point
    '
    If GridPoint Then
        GoTo lbl_7
    End If
    GoTo lbl_6
lbl_7:
    
    '
    ' save result
    '
    For i_ = 0# To N - 1# Step 1
        state.YTbl(i, i_) = state.YC(i_)
    Next i_
    i = i + 1#
    GoTo lbl_3
lbl_5:
    state.RepTerminationType = 1#
    result = False
    ODESolverIteration = result
    Exit Function
lbl_1:
    result = False
    ODESolverIteration = result
    Exit Function
    
    '
    ' Saving state
    '
lbl_rcomm:
    result = True
    state.RState.IA(0#) = N
    state.RState.IA(1#) = M
    state.RState.IA(2#) = i
    state.RState.IA(3#) = j
    state.RState.IA(4#) = k
    state.RState.IA(5#) = KLimit
    state.RState.BA(0#) = GridPoint
    state.RState.RA(0#) = XC
    state.RState.RA(1#) = v
    state.RState.RA(2#) = H
    state.RState.RA(3#) = H2
    state.RState.RA(4#) = Err
    state.RState.RA(5#) = MaxGrowPow
    ODESolverIteration = result
End Function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'ODE solver results
'
'Called after OdeSolverIteration returned False.
'
'INPUT PARAMETERS:
'    State   -   algorithm state (used by OdeSolverIteration).
'
'OUTPUT PARAMETERS:
'    M       -   number of tabulated values, M>=1
'    XTbl    -   array[0..M-1], values of X
'    YTbl    -   array[0..M-1,0..N-1], values of Y in X[i]
'    Rep     -   solver report:
'                * Rep.TerminationType completetion code:
'                    * -2    X is not ordered  by  ascending/descending  or
'                            there are non-distinct X[],  i.e.  X[i]=X[i+1]
'                    * -1    incorrect parameters were specified
'                    *  1    task has been solved
'                * Rep.NFEV contains number of function calculations
'
'  -- ALGLIB --
'     Copyright 01.09.2009 by Bochkanov Sergey
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ODESolverResults(ByRef state As ODESolverState, _
         ByRef M As Long, _
         ByRef XTbl() As Double, _
         ByRef YTbl() As Double, _
         ByRef Rep As ODESolverReport)
    Dim v As Double
    Dim i As Long
    Dim i_ As Long
    Rep.TerminationType = state.RepTerminationType
    If Rep.TerminationType > 0# Then
        M = state.M
        Rep.NFEV = state.RepNFEV
        ReDim XTbl(0 To state.M - 1)
        v = state.XScale
        For i_ = 0# To state.M - 1# Step 1
            XTbl(i_) = v * state.XG(i_)
        Next i_
        ReDim YTbl(0 To state.M - 1, 0 To state.N - 1)
        For i = 0# To state.M - 1# Step 1
            For i_ = 0# To state.N - 1# Step 1
                YTbl(i, i_) = state.YTbl(i, i_)
            Next i_
        Next i
    Else
        Rep.NFEV = 0#
    End If
End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Internal initialization subroutine
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Private Sub ODESolverInit(ByVal SolverType As Long, _
         ByRef y() As Double, _
         ByVal N As Long, _
         ByRef X() As Double, _
         ByVal M As Long, _
         ByVal eps As Double, _
         ByVal H As Double, _
         ByRef state As ODESolverState)
    Dim i As Long
    Dim v As Double
    Dim i_ As Long
    
    '
    ' Prepare RComm
    '
    ReDim state.RState.IA(0# To 5#)
    ReDim state.RState.BA(0# To 0#)
    ReDim state.RState.RA(0# To 5#)
    state.RState.Stage = -1#
    
    '
    ' check parameters.
    '
    If N <= 0# Or M < 1# Or eps = 0# Then
        state.RepTerminationType = -1#
        Exit Sub
    End If
    If H < 0# Then
        H = -H
    End If
    
    '
    ' quick exit if necessary.
    ' after this block we assume that M>1
    '
    If M = 1# Then
        state.RepNFEV = 0#
        state.RepTerminationType = 1#
        ReDim state.YTbl(0 To 1# - 1, 0 To N - 1)
        For i_ = 0# To N - 1# Step 1
            state.YTbl(0#, i_) = y(i_)
        Next i_
        ReDim state.XG(0 To M - 1)
        For i_ = 0# To M - 1# Step 1
            state.XG(i_) = X(i_)
        Next i_
        Exit Sub
    End If
    
    '
    ' check again: correct order of X[]
    '
    If X(1#) = X(0#) Then
        state.RepTerminationType = -2#
        Exit Sub
    End If
    For i = 1# To M - 1# Step 1
        If X(1#) > X(0#) And X(i) <= X(i - 1#) Or X(1#) < X(0#) And X(i) >= X(i - 1#) Then
            state.RepTerminationType = -2#
            Exit Sub
        End If
    Next i
    
    '
    ' auto-select H if necessary
    '
    If H = 0# Then
        v = Abs(X(1#) - X(0#))
        For i = 2# To M - 1# Step 1
            v = MinReal(v, Abs(X(i) - X(i - 1#)))
        Next i
        H = 0.001 * v
    End If
    
    '
    ' store parameters
    '
    state.N = N
    state.M = M
    state.H = H
    state.eps = Abs(eps)
    state.FracEps = eps < 0#
    ReDim state.XG(0 To M - 1)
    For i_ = 0# To M - 1# Step 1
        state.XG(i_) = X(i_)
    Next i_
    If X(1#) > X(0#) Then
        state.XScale = 1#
    Else
        state.XScale = -1#
        For i_ = 0# To M - 1# Step 1
            state.XG(i_) = -1 * state.XG(i_)
        Next i_
    End If
    ReDim state.YC(0 To N - 1)
    For i_ = 0# To N - 1# Step 1
        state.YC(i_) = y(i_)
    Next i_
    state.SolverType = SolverType
    state.RepTerminationType = 0#
End Sub

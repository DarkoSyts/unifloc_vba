'=======================================================================================
'Unifloc 7.9  Vulpes zerda                                           khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
' класс для расчета свойств скважины c газлифтом - распределение давления и температуры в скважине
Option Explicit
Option Base 0
Implements IWell
' ============ general well objects ===========
' штуцер установленный на поверхности
' choke always exist in well (but can have diam = 0 means - no influence on flow)
Private p_choke As New Cchoke
' input fluid object
Private p_fluid As New CPVT                  ' флюид из пласта
Public Trajectory As New CTrajectory         ' полная траектория скважины с инклинометрии (основной способ задания скважины)
' abbient formation object needed for full temperature calculation
' must be accessed through property - in order to pass it to pipes properly
Private p_AmbientForm As New CAmbientFormation
Private p_PTbuf As PTtype
Private p_PTlin As PTtype
'Private p_PTcas As PTtype
Private p_PTwf As PTtype
' temperature params
' температура задается отдельно, поэтому для удобства прямые параметры для работы с температурной моделью скважины заданы
Private p_twh_C As Double
Private p_Tsurf_C As Double
Private p_tbh_C As Double
Private p_Tvalve_C As Double
Private p_tres_C As Double
Private p_Param As PARAMCALC                 ' параметры расчета по трубе
 ' поправочные коэффициенты для расчета распределения давления
Private p_c_calibr_grav As Double
Private p_c_calibr_fric As Double
Public curve As New CCurves ' коллекция кривых с результатами расчетов
Public Event ReportProgress(msg As String)
' ============Gas Lift well objects =======================================
'  класс для описания работы газлифтной скважины
'  предполагается, что есть пакер отделяющий затруб и газлифтные клапана
Public isCalcCasing As Boolean
Private PipesProd As New Collection      ' коллеция труб по которым идет добыча из которых состоит скважина
Private PipesInj As New Collection       '  коллекция труб по которым идет закачка газа
Public valves As New CGLValveSet         ' коллекция клапанов установленных в скважине
Private p_fluidCas As New CPVT
' it is assumed - one fluid in tubing - other in casing
' in gasing gas - with additional amount of gas in flow
Private p_Qgas_inj_scm3day As Double          '
Private p_PTgas_inj As PTtype
' ============ constructor ====================
Private Sub Class_Initialize()
    With p_Param
        .correlation = Ansari
        .FlowDirection = FlowAgainstCoord
        .tempMethod = AmbientTemp
    End With
    p_PTgas_inj.t_c = 30
    p_c_calibr_grav = 1
    p_c_calibr_fric = 1
    isCalcCasing = True
End Sub
'------------------------------------------------------------
' choke general  properties
'------------------------------------------------------------
Property Get choke() As Cchoke
   Set choke = p_choke
End Property
Public Sub SetChoke(dchoke_mm, Optional dtub_mm = 62)
' установка параметров штуцера
   p_choke.Dchoke_m = dchoke_mm / 1000
   p_choke.Ddown_m = dtub_mm / 1000
   p_choke.Dup_m = dtub_mm / 1000
End Sub
 
Public Sub clearChoke()
   p_choke.Dchoke_m = 0
End Sub
Private Function isChoke() As Boolean
   isChoke = p_choke.Dchoke_m > 0
End Function
'------------------------------------------------------------
' fluid general properties
'------------------------------------------------------------
Public Property Get fluid() As CPVT
    Set fluid = p_fluid
End Property
Public Property Get fluidTub() As CPVT
    Set fluidTub = p_fluid
End Property
Public Property Get fluidCas() As CPVT
    Set fluidCas = p_fluidCas
End Property
Public Property Set fluid(val As CPVT)
    Dim pipe As CPipe
    ' set main tubing fluid here
    Set p_fluid = val
    ' set clone fluid object in casing
    Set p_fluidCas = val.Clone
    
    For Each pipe In PipesProd
        Set pipe.fluid = p_fluid
    Next pipe
    For Each pipe In PipesInj
        Set pipe.fluid = p_fluidCas
    Next pipe
    
    Set choke.fluid = p_fluid
    Set valves.fluid = p_fluid
End Property
' ---------------------------------------------------------------
' flow correlations tuning methods
' ---------------------------------------------------------------
Public Property Get c_calibr_grav() As Double
   c_calibr_grav = p_c_calibr_grav
End Property
Public Property Get c_calibr_fric() As Double
   c_calibr_fric = p_c_calibr_fric
End Property
Public Property Let c_calibr_grav(val As Double)
   Dim pipe As CPipe
   If val > 0 And val < 2 Then
   ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
        For Each pipe In PipesProd
            pipe.c_calibr_grav = val
        Next pipe
        For Each pipe In PipesInj
            pipe.c_calibr_grav = val
        Next pipe
        p_c_calibr_grav = val
        If val <> 1 Then addLogMsg_debug "CWellGL.c_calibr_grav = " & str(val) & " warning. correction to multiphase flow correlation active!"
   Else
        addLogMsg_debug "CWellGL.c_calibr_grav: value " & str(val) & " not set. Out of range"
   End If
End Property
 
Public Property Let c_calibr_fric(val As Double)
   Dim pipe As CPipe
   If val > 0 And val < 2 Then
   ' не стоит подстрочный коэффициент менять слишком сильно - если что тут можно поправить
        For Each pipe In PipesProd
            pipe.c_calibr_fric = val
        Next pipe
        For Each pipe In PipesInj
            pipe.c_calibr_fric = val
        Next pipe
        p_c_calibr_fric = val
        If val <> 1 Then addLogMsg_debug "CWellGL.c_calibr_fric = " & str(val) & " warning. correction to multiphase flow correlation friction active!"
   Else
        addLogMsg_debug "CWellGL.c_calibr_fric: value " & str(val) & " not set. Out of range"
   End If
End Property
 
Public Property Get HFlowCorrelation() As H_CORRELATION
    HFlowCorrelation = param.correlation
End Property
Public Property Let HFlowCorrelation(val As H_CORRELATION)
    Dim prm As PARAMCALC
    prm = param
    prm.correlation = val
    param = prm
End Property
 
Public Property Get TempCorrelation() As TEMP_CALC_METHOD
    TempCorrelation = param.tempMethod
End Property
 
Public Property Let TempCorrelation(val As TEMP_CALC_METHOD)
    Dim prm As PARAMCALC
    prm = param
    prm.tempMethod = val
    param = prm
End Property
 
Public Property Get param() As PARAMCALC
    param = p_Param
End Property
Public Property Let param(val As PARAMCALC)
    p_Param = val
    Dim pipe As CPipe
    
    For Each pipe In PipesProd
        pipe.param = val
    Next pipe
    For Each pipe In PipesInj
        pipe.param = val
    Next pipe
End Property
 
'------------------------------------------------------------
' temperature general properties
'------------------------------------------------------------
Public Property Get t_line_C() As Double
    t_line_C = p_PTlin.t_c
End Property
Public Property Get t_buf_C() As Double
    t_buf_C = p_PTbuf.t_c
End Property
 
Public Property Get t_bh_C() As Double
    t_bh_C = p_PTwf.t_c
End Property
 
Public Property Get t_wh_C() As Double
    t_wh_C = p_PTbuf.t_c
End Property
Public Property Get t_surf_C() As Double
    On Error Resume Next
    t_surf_C = p_PTbuf.t_c
    t_surf_C = AmbientForm.AmbTemp_С(0)
End Property
Public Property Get AmbientForm() As CAmbientFormation
    Set AmbientForm = p_AmbientForm
End Property
Public Property Set AmbientForm(ByVal vNewValue As CAmbientFormation)
    Dim pipe As CPipe
    Set p_AmbientForm = vNewValue
    For Each pipe In PipesProd
        Set pipe.AmbientForm = p_AmbientForm
    Next pipe
    For Each pipe In PipesInj
        Set pipe.AmbientForm = p_AmbientForm
    Next pipe
    
    Call InitWellTemperature
End Property
'------------------------------------------------------------
' pressure general properties
'------------------------------------------------------------
Public Property Get p_line_atma() As Double
   p_line_atma = p_PTlin.p_atma
End Property
Public Property Get p_buf_atma() As Double
' buffer pressure
   p_buf_atma = p_PTbuf.p_atma
End Property
Public Property Get p_wf_atma() As Double
' давление на забое
   p_wf_atma = p_PTwf.p_atma
End Property
'Public Property Get p_an_atma() As Double
'' annulus presure
'   p_an_atma = p_PTgas_inj.p_atma
'End Property
Public Property Get p_cas_atma() As Double
    p_cas_atma = p_PTgas_inj.p_atma
End Property
'------------------------------------------------------------
' well rates general properties
'------------------------------------------------------------
Property Let qliq_sm3day(Qval_scm3day As Double)
   fluid.qliq_sm3day = Qval_scm3day
   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
   Set fluid = fluid
 '  p_Calculated = False
End Property
' дебит жидкости из скважины в поверхностных условиях
Public Property Get qliq_sm3day() As Double
   qliq_sm3day = p_fluid.qliq_sm3day
End Property
Public Property Get w_kgsec() As Double
'    массовый расход продукции рассчитаем
   w_kgsec = p_fluid.wm_kgsec
End Property
Public Property Get q_oil_sm3day() As Double
   q_oil_sm3day = p_fluid.q_oil_sm3day
End Property
Public Property Get Qo_sctday() As Double
   Qo_sctday = qliq_sm3day * (1 - p_fluid.fw_fr) * p_fluid.gamma_o
End Property
Public Property Get q_wat_sm3day() As Double
   q_wat_sm3day = qliq_sm3day * p_fluid.fw_fr
End Property
Public Property Get qg_scm3day() As Double
   qg_scm3day = p_fluid.q_gas_sm3day
End Property
Property Get fw_perc() As Double
    fw_perc = p_fluid.fw_perc
End Property
Property Let fw_perc(wcval As Double)
   Dim Wc As Double
   Wc = wcval / 100
   fluid.fw_fr = Wc
   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
   Set fluid = p_fluid
End Property
Property Let rp_m3m3(Rpval As Double)
   fluid.rp_m3m3 = Rpval
   ' далее надо сбросить все флюиды которые были в системе на единый, что возможно потребует пересчета
   Set fluid = p_fluid
End Property
' ---------------------------------------------------------------
' service function
' ---------------------------------------------------------------
   
 Public Function Clone() As CWellGL
    Dim wl As New CWellGL
    Dim i As Integer
    Set wl.Trajectory = Trajectory   ' это должно сработать вместо инициализации
    Call wl.choke.Copy(choke)
    Set wl.fluid = fluid.Clone
    
    Set Clone = wl
 End Function
    
 
 
' =======================================
' методы инициализации скважины
' =======================================
Public Sub InitWellConstruction(ByVal hperf_m As Double, _
                                ByVal htub_m As Double, _
                        Optional ByVal d_cas_mm As Double = 125, _
                        Optional ByVal dtub_mm As Double = 72, _
                        Optional ByVal udl_m As Double = 0, _
                        Optional ByVal hmes_incl_range_m_ = -1, _
                        Optional ByVal hvert_incl_range_m_ = -1, _
                        Optional ByVal hmes_dcas_range_m_ = -1, _
                        Optional ByVal dcas_range_mm_ = -1, _
                        Optional ByVal hmes_dtub_range_m_ = -1, _
                        Optional ByVal dtub_range_mm_ = -1)
    ' универсальный метод инициализации скважины - должен использоваться для инициализации скважины
    ' поддерживает три варианта инициалиции
    '       - с упрощенным набором данных с удлинением (загрузка из тех режима)
    '       - с заданием инклинометрии через range и упрощенным набором труб (диаметры)
    '       - с заданием инклинометрии и диаметров с использованием range
    '
    ' параметры обязательные для всех вариантов задания
    ' hperf_m               - глубина перфорации измеренная, м. Используется для расчета забойного давления
    ' htub_m                - глубина спуска НКТ измеренная, м. Соответствует глубине спуска насоса
    '
    ' параметры упрощенного режима задания
    ' d_cas_mm               - внутренний диамет эксплуатационной колонны, мм
    ' dtub_mm               - внешний диамет НКТ, мм (толщина стенки 10 мм)
    ' udl_m                 - удлинение на глубину перфорации, м (разница между измеренной и вертикальной глубиной)
    '
    ' параметры детального задания скважины  (все - вертикальные range)
    ' hmes_incl_range_m_    - измеренная глубина скважины для задания инклинометрии
    ' hvert_incl_range_m_   - вертикальная глубина скважины для задания инклинометрии
    '                       - если инклинометрии как range задана, то удлинение игнорируется
    '
    ' hmes_dcas_range_m_    - измеренная глубина для задания диаметра эксплуатационной колонны (начинается с 0)
    ' dcas_range_mm_        - диаметр эксплуатационной колонны на соответствующей глубине (действует от глубины и вниз до след изменения)
    ' hmes_dtub_range_m_    - измеренная глубина для задания диаметра НКТ
    ' dtub_range_mm_        - диаметр НКТ внешний на соответствующей глубине (действует от глубины и вниз до след изменения)
    '                       - для полного задания скважины все range должны быть заданы
    
    
    
    Dim simpleNumbers As Boolean
    Dim fullRange As Boolean
    Dim inclRange As Boolean
    Dim fullArray As Boolean
    
    simpleNumbers = IsNumeric(hmes_incl_range_m_)
    inclRange = IsObject(hmes_incl_range_m_) And IsObject(hvert_incl_range_m_)
    fullRange = inclRange And IsObject(hmes_dcas_range_m_) And IsObject(dcas_range_mm_) And _
                              IsObject(hmes_dtub_range_m_) And IsObject(dtub_range_mm_)
    
    If simpleNumbers Then
    ' use simple numbers here
        Call FillWellConstructionSimple(hperf_m, htub_m, udl_m, d_cas_mm, dtub_mm)
    ElseIf fullRange Then
        Call FillWellConstructionRangeAll(hmes_incl_range_m_, hvert_incl_range_m_, hmes_dcas_range_m_, _
                              dcas_range_mm_, hmes_dtub_range_m_, dtub_range_mm_, _
                              hperf_m, htub_m)
'    ElseIf inclRange Then
'        Call FillWellConstructionRange(hmes_incl_range_m_, hvert_incl_range_m_, hperf_m, htub_m, d_cas_mm, dtub_mm)
    End If
    
End Sub
Public Sub InitWellTemperature(Optional ByVal tbh_C As Double = -1, _
                               Optional ByVal twh_C As Double = -1, _
                               Optional ByVal hmes_tamb_arr_m_ = -1, _
                               Optional ByVal tamb_arr_C_ = -1)
   ' основная функция инициализации температуры в скважине
   ' задает по исходным данным объект AmbientForm, который определяет параметры температуры в скважине
   '
   ' если никакие параметры не заданы, скважине переинициализируется используя уже заданный объект p_AmbientForm
   '
   ' tbh_C              - температура на забое скважины
   ' twh_C              - температура на устье скважины
   ' hmes_tamb_arr_m_   - массив (range) измеренных глубин для задания распределения температуры по глубине
   ' tamb_arr_C_        - значения температуры по глубине
   
   
    Dim simpleNumbers As Boolean
    Dim ambRange As Boolean
    Dim newTempValues As Boolean
    
    Dim geoGrad As New CInterpolation
    Dim ambTemp As New CAmbientFormation
    Dim RangX As Range, RangY As Range
On Error GoTo err1:
    simpleNumbers = IsNumeric(hmes_tamb_arr_m_)
    ambRange = IsObject(hmes_tamb_arr_m_) And IsObject(tamb_arr_C_)
    newTempValues = ((tbh_C > 20) And (twh_C > 0)) Or ambRange
    
    If newTempValues Then
        If simpleNumbers Then
            geoGrad.AddPoint 0, twh_C
            geoGrad.AddPoint Trajectory.Hperfvert_m, tbh_C
        ElseIf ambRange Then
            Set RangX = hmes_tamb_arr_m_
            Set RangY = tamb_arr_C_
            Call geoGrad.loadFromVertRange(RangX, RangY)
        End If
        Set ambTemp.AmbTempCurve = geoGrad
        Set p_AmbientForm = ambTemp
    End If
    
    ' here we must have p_AmbientForm ready for initialisation
    
    p_tbh_C = p_AmbientForm.AmbTemp_С(Trajectory.Hperfvert_m)
    p_twh_C = p_AmbientForm.AmbTemp_С(0)
    p_Tsurf_C = p_twh_C
    p_tres_C = fluid.tres_C
    
    ' инициализируем все элементы скважины для расчета по линейной зависимости от измеренной глубине
    ' это метод расчета по умолчанию
    ' все другие режимы расчета используют объект p_AmbientForm и не зависят от этой инициализации
    Dim TempGrad As Double
    Dim tintake_C As Double
    TempGrad = (p_tbh_C - p_twh_C) / Trajectory.hperf_m
    
     
    Dim i As Integer
    Dim tempDown_C As Double
    Dim tempUp_C As Double
    Dim pipe As CPipe
    Dim HvalveVert0_m  As Double
    
    
    tempUp_C = p_tbh_C
    For i = 1 To PipesProd.Count
         Set pipe = PipesProd(i)
         tempDown_C = tempUp_C
         tempUp_C = tempDown_C - TempGrad * pipe.LengthMes_m
         pipe.InitTlinear tempUp_C, tempDown_C
    Next i
    
    HvalveVert0_m = Trajectory.HabsZ_m(valves.Hmes_lowest_m)
    tempUp_C = AmbientForm.AmbTemp_С(HvalveVert0_m)
    For i = 1 To PipesInj.Count
         Set pipe = PipesInj(i)
         tempDown_C = tempUp_C
         tempUp_C = tempDown_C - TempGrad * pipe.LengthMes_m
         pipe.InitTlinear tempUp_C, tempDown_C
    Next i
    ' зададим значения всех температур в ключевых точках в соответствии с исходными параметрами
    ' некоторые из этих параметров потом могут быть перевычисленны
    p_PTbuf.t_c = p_twh_C
    p_PTlin.t_c = p_twh_C
    p_PTgas_inj.t_c = p_twh_C
    p_PTwf.t_c = p_tbh_C
    
    Exit Sub
err1:
    Dim errmsg As String
    errmsg = "CWellGL.InitWellTemperature: error in temperature init " & sDELIM & Err.Description
    RaiseEvent ReportProgress(errmsg)
    Err.Raise kErrInitCalc, Err.Source, errmsg
End Sub
' метод инициализации газлифтной скважины
' должен уметь задавать все трубы по скважине из исходных данных по траектории
'
'
Public Sub IninWellGLV(Optional ByVal GLV_Hmes_m = 0, _
                       Optional ByVal GLV_dvalve_mm = 0, _
                       Optional ByVal GLV_Pbellow_atma = 0)
   Dim RangeX As Range
   Dim RangeY As Range
   If IsObject(GLV_Hmes_m) Then
        Set RangeX = GLV_Hmes_m
        Set RangeY = GLV_dvalve_mm
        Call valves.loadFromVertRange(RangeX, RangeY)
   ElseIf IsArray(GLV_Hmes_m) Then
        Call valves.loadFromArray(GLV_Hmes_m, GLV_dvalve_mm, GLV_Pbellow_atma)
   End If
  
End Sub
Private Sub FillWellConstructionSimple(ByVal hperf_m As Double, _
                    ByVal htub_m As Double, _
                    ByVal udl_m As Double, _
                    ByVal d_cas_mm As Double, _
                    ByVal dtub_mm As Double)
' метод для инициализации скважины простыми числами
On Error GoTo err1:
   Dim errmsg As String
   
   ' задаем траекторию свола скважины, на основе которого потом будет задано все остальное
   Dim tr As New CTrajectory
   Dim HabsCurve_m As New CInterpolation  ' инклинометрия - две точки
   HabsCurve_m.AddPoint 0, 0
   HabsCurve_m.AddPoint hperf_m, hperf_m - udl_m
   
   Dim DcasCurve_mm As New CInterpolation  ' casing diameter
   DcasCurve_mm.AddPoint 0, d_cas_mm
   DcasCurve_mm.AddPoint hperf_m, d_cas_mm  ' casing goes from top to bottom here
   
   Dim DtubCurve_mm As New CInterpolation  ' tubing diameter
   DtubCurve_mm.AddPoint 0, dtub_mm
   DtubCurve_mm.AddPoint htub_m, dtub_mm  ' goes to tubing setting depth
   
   ' initialise trajectory (same as ESP well class)
   Call tr.InitTrajectoryHabs(HabsCurve_m, DcasCurve_mm, DtubCurve_mm, hperf_m, htub_m)
   Set Trajectory = tr
   Call FillWellConstructionTr
   
   Exit Sub
   
err1:
   errmsg = "CWellGL.FillWellConstructionSimple: Ошибка простой инициализации скважины " & sDELIM & Err.Description
   RaiseEvent ReportProgress(errmsg)
   Err.Raise kErrInitCalc, Err.Source, errmsg
End Sub
Private Sub FillWellConstructionRangeAll(ByVal Incl_Hmes_m_ As Range, _
                           ByVal Incl_Hvert_m_ As Range, _
                           ByVal hmes_dcas_m_ As Range, _
                           ByVal dcas_arr_mm_ As Range, _
                           ByVal hmes_dtub_m_ As Range, _
                           ByVal dtub_arr_mm_ As Range, _
                           ByVal hperf_m As Double, _
                           ByVal htub_m As Double)
' метод для инициализации скважины из диапазонов измнения ключевых параметров
On Error GoTo err1:
   Dim HabsCurve_m As New CInterpolation
   Dim DcasCurve_mm As New CInterpolation
   Dim DtubCurve_mm As New CInterpolation
   Dim geoGrad As New CInterpolation
   Dim ambTemp As New CAmbientFormation
   Dim errmsg As String
   
   Call HabsCurve_m.loadFromVertRange(Incl_Hmes_m_, Incl_Hvert_m_)
   Call DcasCurve_mm.loadFromVertRange(hmes_dcas_m_, dcas_arr_mm_)
   Call DtubCurve_mm.loadFromVertRange(hmes_dtub_m_, dtub_arr_mm_)
  
   hperf_m = DcasCurve_mm.maxx
   htub_m = DtubCurve_mm.maxx
   
   Call Trajectory.InitTrajectoryHabs(HabsCurve_m, DcasCurve_mm, DtubCurve_mm, hperf_m, htub_m, valves)
   Call FillWellConstructionTr
   
   Exit Sub
err1:
   errmsg = "CWellESP.InitWellRangeAll: Ошибка простой инициализации скважины " & sDELIM & Err.Description
   RaiseEvent ReportProgress(errmsg)
   Err.Raise kErrInitCalc, Err.Source, errmsg
End Sub
' ============================================================
' основные расчетные функции
' ============================================================
Public Sub SetQgasInj(Optional ByVal Pcas_inj_atma As Double = 1, _
                      Optional ByVal Qgas_inj_scm3day As Double = -1)
    p_Qgas_inj_scm3day = Qgas_inj_scm3day
    p_PTgas_inj.p_atma = Pcas_inj_atma
End Sub
Public Function calc_plin_pwf_atma(ByVal pwf_atma As Double, _
                            Optional ByVal saveCurve As CALC_RESULTS = noCurves) As Double
' @brief расчет давления на устье через забойное давление (снизу -> вверх)
' @param pwf - исходное забойное давление и температура
' @Qgas_inj_scm3day - gas rate injected. If given - used at deepest GLV
' @CalcCasing - флаг показывает надо ли считать ветку распределения давления по забтрубу - динамический уровень и затрубное давление
' @CalcChoke - показывает надо ли считать штуцер
' @saveCurve - показывает насколько детально надо сохранять результаты расчета
Dim Tintake_esp_C As Double
Dim PT_temp As PTtype
Dim PTcas_temp As PTtype
Dim Tan_C As Double
Dim pcur As CInterpolation
Dim i As Integer
Dim pipe As CPipe
Dim Qgfree_tot_scm3day As Double
Qgfree_tot_scm3day = 0
Dim fluid_Pipe_Below As CPVT
' first initialize temp fluid with general one
Set fluid_Pipe_Below = fluid
' flag show if lowest GLV has been acounted
Dim LowestGLVdone As Boolean
LowestGLVdone = False
Dim Qgas_inj_GLV_scm3day As Double
Qgas_inj_GLV_scm3day = 0
    
On Error GoTo err1:
    ' 1. Start calculation from pwf, Tbh
    p_PTwf.p_atma = pwf_atma
    PT_temp = p_PTwf
    PTcas_temp = p_PTgas_inj 'SetPT(Pcas_inj_atma, p_PTcas.T_C)
    
    ' 2. calculate pressure distribution in annulus
    
    For i = PipesInj.Count To 1 Step -1
        Set pipe = PipesInj(i)
        pipe.param = param_calc_against_flow(Gas, TempCorrelation)
        PTcas_temp = pipe.calc_dPipe(PTcas_temp.p_atma, saveCurve)
        If Not pipe.GLVin Is Nothing Then
            ' if  there is a valve - save PT in casing at valve intake
            pipe.GLVin.p_in_atma = PTcas_temp.p_atma
            pipe.GLVin.t_c = PTcas_temp.t_c
        End If
    Next i
    
    ' 3. calc tubing pressure
    For i = 1 To PipesProd.Count
        ' first segment - from bottom to tubing depth then goes up
        Set pipe = PipesProd(i)
        ' taking fluid from previos segment - if we had gas injected below it will acounted here
        Set pipe.fluid = fluid_Pipe_Below
        ' check if there is a valve on pipe bottom
        ' GLV meant it is possible ijection point
        If Not pipe.GLVin Is Nothing Then
            ' if valve set up then estimate gas coming through valve
            pipe.GLVin.p_out_atma = PT_temp.p_atma   ' pressure at pipe bottom from previos step
            pipe.GLVin.t_c = PT_temp.t_c
            ' adding additional gas coming trough valve
On Error GoTo err2:
            If p_Qgas_inj_scm3day > 0 Then
                ' use manual Qgas in well
                If Not LowestGLVdone Then
                    Qgas_inj_GLV_scm3day = p_Qgas_inj_scm3day
                    LowestGLVdone = True
                Else
                    Qgas_inj_GLV_scm3day = 0
                End If
            Else
                Qgas_inj_GLV_scm3day = pipe.GLVin.calc_q_gas_sm3day(-1, -1, -1)
              '  i = i / 0
            End If
            pipe.GLVin.q_gas_inj_scm3day = Qgas_inj_GLV_scm3day
On Error GoTo err1:
            Qgfree_tot_scm3day = Qgfree_tot_scm3day + Qgas_inj_GLV_scm3day
            If Qgas_inj_GLV_scm3day > 0 Then
                Set pipe.fluid = fluid_Pipe_Below.Clone
                pipe.fluid.q_gas_free_sm3day = Qgfree_tot_scm3day
                Set fluid_Pipe_Below = pipe.fluid
            End If
        End If
        ' считаем снизу в сторону буферного
        pipe.param = param_calc_along_flow(HFlowCorrelation, TempCorrelation)
        PT_temp = pipe.calc_dPipe(PT_temp.p_atma, saveCurve)
    Next i
    p_PTbuf = PT_temp
    p_PTlin = p_PTbuf
On Error GoTo err3:
    ' 4. Расчет линейного давления по штуцеру
    If choke.Dchoke_m > 0 Then      ' пока отключено
        Set choke.fluid = pipe.fluid   ' take fluid from last pipe
        p_PTlin = choke.calc_choke_plin(p_PTbuf)
        If p_PTlin.p_atma < 0 Then
            p_PTlin.p_atma = 1
        End If
    End If
On Error GoTo err1:
    calc_plin_pwf_atma = PT_temp.p_atma
    
    If saveCurve > 0 Then
        For i = 1 To PipesProd.Count
            Set pipe = PipesProd(i)
            Call curve(str_PtubHmes_curve).AddPointsCurve(pipe.Curves("c_P"))
            Call curve(str_TtubHmes_curve).AddPointsCurve(pipe.Curves("c_T"))
            Call curve(str_TambHmes_curve).AddPointsCurve(pipe.Curves("c_Tamb"))
            If saveCurve > 1 Then
                Call curve(str_HlHmes_curve).AddPointsCurve(pipe.CurvesOut("c_Hl"))
                curve(str_HlHmes_curve).yName = "Hl"
            End If
        Next i
        For i = 1 To PipesInj.Count
           Set pipe = PipesInj(i)
           Call curve(str_PcasHmes_curve).AddPointsCurve(pipe.Curves("c_P"))
           Call curve(str_TcasHmes_curve).AddPointsCurve(pipe.Curves("c_T"))
        Next i
        
        curve(str_PtubHmes_curve).xName = "hmes ptub"
        curve(str_PtubHmes_curve).yName = "Ptub"
        
        curve(str_TtubHmes_curve).xName = "hmes Ttub"
        curve(str_TtubHmes_curve).yName = "Ttub"
        
        curve(str_TambHmes_curve).xName = "hmes Tamb"
        curve(str_TambHmes_curve).yName = "Tamb"
        
        curve(str_PcasHmes_curve).xName = "hmes pcas"
        curve(str_PcasHmes_curve).yName = "pcas"
        
        curve(str_TcasHmes_curve).xName = "hmes pcas"
        curve(str_TcasHmes_curve).yName = "Tcas"
    End If
    Exit Function
err1:
    On Error Resume Next
    RaiseEvent ReportProgress("CWellGL.calc_plin_pwf_atma: some general error")
    Err.Raise Err.Number, Err.Source, Err.Description
    Exit Function
err2:
    On Error Resume Next
    addLogMsg "CWellGL.calc_plin_pwf_atma:error while GLV Hmes = " & CStr(pipe.GLVin.h_mes_m) & " calc - Qgas_inj_GLV_scm3day = " & CStr(Qgas_inj_GLV_scm3day)
    Resume Next
    Exit Function
err3:
    On Error Resume Next
    addLogMsg "CWellGL.calc_plin_pwf_atma:error while choke calc - choke have been  ignored"
    Resume Next
End Function
Public Function calc_pwf_plin_atma(ByVal plin_atma As Double, _
                                    ByVal tbh_C As Double, _
                                    Optional saveCurve As CALC_RESULTS = noCurves)
' @brief calc_pwf_plin_atma расчет забойного давления по известному давлению в линии и конструкции скважины дихотомией
' @param plin_atma - давление в линии
' @param Hd - динамический уровень
' @param tbh_C - температура на забое скважины
' @return Подсчитанное для заданного линейного давление
On Error GoTo err1:
    Dim Pwf1 As Double      ' первое приближение
    Dim PwfUp As Double, PwfDown As Double
    Dim PlinUp As Double, PlinDown As Double
    Dim Plin0 As Double, Plin1 As Double
    Dim found_solution As Boolean
    Dim i As Integer
    found_solution = False
    i = 0
    Pwf1 = 60
    PwfUp = -1
    PwfDown = -1
    Do
        ' ищем  приближения
        Plin1 = calc_plin_pwf_atma(Pwf1, saveCurve:=noCurves)
        If (Abs(Plin1 - plin_atma) < const_well_P_tolerance) Then
             found_solution = True
             p_PTwf.p_atma = Pwf1
             p_PTwf.t_c = tbh_C
        End If
        If Not found_solution Then
          If Plin1 > plin_atma Then
              PwfUp = Pwf1
              PlinUp = Plin1
              If PwfDown < 0 Then
                  Pwf1 = PwfUp / 2
              Else
                  Pwf1 = PwfDown + (PwfUp - PwfDown) * (plin_atma - PlinDown) / (PlinUp - PlinDown)
              End If
          Else
              PwfDown = Pwf1
              PlinDown = Plin1
              If PwfUp < 0 Then
                  Pwf1 = Pwf1 * 2
              Else
                  Pwf1 = (PwfUp + PwfDown) / 2
              End If
          End If
        End If
        i = i + 1
    Loop While Not found_solution And i < 20
    
    If i = 20 Then
       addLogMsg "CWellGL.calc_pwf_plin_atma: max iteration num reached. i = " & CStr(i) & " tolerance reached = " & CStr(Abs(Plin1 - plin_atma))
    End If
    
   ' Call SetQgasInj(Pcas_inj_atma, Qgas_inj_scm3day)
    p_PTlin = SetPT(calc_plin_pwf_atma(p_PTwf.p_atma, saveCurve:=saveCurve), t_buf_C)
    
    If Abs(p_line_atma - plin_atma) > const_well_P_tolerance Then
       addLogMsg "CWellGL.calc_pwf_plin_atma: BHP estimation error exceeds tolerance " & const_well_P_tolerance & ". Equal = " & Abs(Me.p_line_atma - plin_atma)
    End If
    calc_pwf_plin_atma = p_PTwf.p_atma
    
    Exit Function
err1:
    ' тут надо среагировать на ошибку
        On Error Resume Next
    RaiseEvent ReportProgress("CWellGL.calc_plin_pwf_atma: some general error")
    Err.Raise Err.Number, Err.Source, Err.Description
    Exit Function
 End Function
 
' =============================================================================
' specific properties and functions
' =============================================================================
Private Sub FillWellConstructionTr()
    Dim i As Integer, j As Integer
    Dim segmUp_m As Double
    Dim segmDown_m As Double
    Dim pipe As CPipe
    ' need to fill up individual pipe segments in well (production line)
    ' 1 segment from bottom hole to Htub  (lowest)
    ' next - from Htub to valve(0) depth - and so on
    ' at this point valve depth values must be ok (sorted and non zero)
        
    ' set up pipe segments for injection line
    ' 1 segment from lowest valve to upper
    ' not interested for now what happens bellow lowest valve
    
    ' set up csing flow below tubing depth
    segmDown_m = Trajectory.hperf_m
    segmUp_m = Trajectory.Htubing_m
    If segmDown_m > segmUp_m Then
        ' first segment from bottom to tubing depth exist
        ' hae to be created here
        Set pipe = New CPipe  ' creating new object
        Set pipe.fluid = fluid
        Call pipe.InitPipeConstrTr(Trajectory, segmUp_m, segmDown_m, pipeCasing)
        PipesProd.Add pipe    ' save it to collection
    End If
    segmDown_m = segmUp_m
    i = valves.Count
    If i > 0 Then
        segmUp_m = valves.Hmes_m(i)
    Else
        segmUp_m = 0
    End If
    For j = i To 0 Step -1
        If segmUp_m < segmDown_m Then
            Set pipe = New CPipe  ' creating new object
            Set pipe.fluid = fluid
            Call pipe.InitPipeConstrTr(Trajectory, segmUp_m, segmDown_m, pipeTubing)
            If j < i Then
                Set pipe.GLVin = valves.valves(j + 1)
            End If
            PipesProd.Add pipe    ' save it to collection
            segmDown_m = segmUp_m
        End If
        If j > 1 Then
            segmUp_m = valves.Hmes_m(j - 1)
        Else
            segmUp_m = 0
        End If
        If segmUp_m < segmDown_m Then
            ' if exist segment
            Set pipe = New CPipe  ' creating new object
            Set pipe.fluid = fluid
            Call pipe.InitPipeConstrTr(Trajectory, segmUp_m, segmDown_m, pipeAnnulus)
            Set pipe.GLVin = valves.valves(j)
            PipesInj.Add pipe
        End If
    Next j
       
'   Hvd_m = Trajectory.Htubing_m ' определим глубину спуска установки
'   p_Hspvert_m = Trajectory.HabsZ_m(p_Hsp_m)    ' в том числе по вертикали
'   Call p_Pipe_HspHvd.InitPipeConstrTr(Trajectory, Trajectory.Htubing_m, Trajectory.hperf_m, 1)
    choke.Dup_m = 0.06
    choke.Ddown_m = 0.06
    For Each pipe In PipesProd
        Set pipe.AmbientForm = AmbientForm
    Next pipe
    For Each pipe In PipesInj
        Set pipe.AmbientForm = AmbientForm
    Next pipe
    
End Sub
' Public Sub InitTempTr(geoGrad As CInterpolation)
'' процедура для инициализации температуры в скважине, для линейнго расчета
'' при линейном расчете предполагается,
'' что температура меняется линейно относительно глубины скважины
''
'   Dim TempGradVert As Double
'   Dim pipe As CPipe
'
'   p_PTwf.T_C = geoGrad.getPoint(geoGrad.maxx)
'   p_PTbuf.T_C = geoGrad.getPoint(geoGrad.minx)
'
'   TempGradVert = (p_PTwf.T_C - p_PTbuf.T_C) / Trajectory.hperf_m
'
'   For Each pipe In PipesProd
'       pipe.dTdLinit = TempGradVert
'   Next pipe
'   For Each pipe In PipesInj
'       pipe.dTdLinit = TempGradVert
'   Next pipe
'
'   TempCorrelation = GeoGradTemp
'
'End Sub
 
 
Public Property Get p_gas_inj_atma() As Double
    p_gas_inj_atma = p_PTgas_inj.p_atma
End Property
Public Property Let p_gas_inj_atma(val As Double)
    p_PTgas_inj.p_atma = val
End Property
' ======================================================================
' Iwell implementation
' ======================================================================
Private Function IWell_CalcDown(pline_atma As Double, Optional saveCurve As CALC_RESULTS = 0&) As Double
 '   IWell_CalcDown = calc_pwf_plin_atma(Pline_atma, tbh_C, saveCurve:=saveCurve)
End Function
Private Function IWell_CalcUp(pwf_atma As Double, Optional saveCurve As CALC_RESULTS = 0&) As Double
 '   IWell_CalcUp = calc_plin_pwf_atma(pwf_atma, saveCurve:=saveCurve)
End Function
Private Function IWell_CalcWell(pwf_atma As Double, Optional saveCurve As CALC_RESULTS = 0&) As Double
End Function
Private Property Get IWell_cfBettaFric() As Double
    IWell_cfBettaFric = c_calibr_fric
End Property
Private Property Get IWell_cfBettaGrav() As Double
    IWell_cfBettaGrav = c_calibr_grav
End Property
Private Property Get IWell_cDegradChoke() As Double
    IWell_cDegradChoke = choke.c_degrad_fr
End Property
Private Property Get IWell_cfESP() As Double
    IWell_cfESP = ESP.c_calibr_head
    ' пока учитывается только по напору
    ' наверное потом надо будет добавить по дебиту и по мощности как то
End Property
Private Property Get IWell_cfFw() As Double
    IWell_cfFw = 0
End Property
Private Property Get IWell_cfGLinj() As Double
    IWell_cfGLinj = 0
End Property
Private Property Get IWell_cfRp() As Double
    IWell_cfRp = 0
End Property
Private Property Get IWell_fw() As Double
    IWell_fw = fluid.fw_perc
End Property
Private Property Get IWell_Pintake() As Double
    IWell_Pintake = 0
End Property
Private Property Get IWell_Pline() As Double
    IWell_Pline = p_PTlin.p_atma
End Property
Private Property Get IWell_pwf() As Double
    IWell_pwf = p_PTwf.p_atma
End Property
Private Property Get IWell_Pwh() As Double
    IWell_Pwh = p_PTbuf.p_atma
End Property
Private Property Get IWell_Qgascas() As Double
    IWell_Qgascas = 0
End Property
Private Property Get IWell_Qgasinj() As Double
    IWell_Qgasinj = 0
End Property
Private Property Let IWell_Qliq(RHS As Double)
    fluid.qliq_sm3day = RHS
End Property
Private Property Get IWell_Qliq() As Double
    IWell_Qliq = fluid.qliq_sm3day
End Property

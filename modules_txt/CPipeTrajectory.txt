'=======================================================================================
'Unifloc 7.17  Test                                          khabibullin.ra@gubkin.ru
'Petroleum engineering calculations modules (macroses)
'2000 - 2019
'
'=======================================================================================
'
Option Explicit
' Класс описывающий траекторию трубы. Содержит методы для работы с инклинометрией и траекторией
' На вход подаются данные по траектории или инклинометрии в исходном виде (из базы данных)
' На выходе объект пригодный для проведения расчетов с использованием класса скважины и трубы
' У трубы могут меняться наклон по участкам и диаметр - шероховатость и толщина стенки постоянны для
' всего сегмента.
'
' История
' 2016.01.18    Хабибуллин Ринат
' 2019.10.25    рефакторинг для упрощения и оптимизации логики (убраны лишние сущности из скважины h_perf)
' тип описывающий полную конструкцию скважины в заданной точке
Private Type WELL_POINT_FULL
    h_mes_m As Double           ' измеренная глубина
    ang_deg As Double           ' угол  от вертикали
    h_abs_m As Double           ' абсолютная глубина
    diam_in_m As Double         ' диаметр трубы, внутренний
    diam_out_m As Double        ' диаметр трубы, внешний
    roughness_m As Double       ' шероховатость
End Type
Private h_abs_init_m_ As New CInterpolation      ' исходный массив абсолютных глубин
Private angle_init_deg_ As New CInterpolation    ' исходный массив углов
Private diam_init_m_ As New CInterpolation       ' исходный массив значений диаметров НКТ
Private wall_thickness_mm_                       ' пока считаем что НКТ всегда имеет одинаковую толщину - потом можно будет учесть
Private wall_roughness_m_                        ' пока также считаем, что шероховатость везде тоже одинакова
Private pipe_trajectory_() As WELL_POINT_FULL     ' полная конструкция скважины пригодная для расчетов - итоговое свойство класса
Private num_points_out_ As Integer               ' количество точек в выходном массиве
Private length_between_points_m_ As Double       ' мин растояние между точками при генерации исходного массива
Private construction_points_curve_ As New CInterpolation  ' точки которые должны быть добавлены (измеренная глубина - абсолютная глубина)
Private h_points_curve_ As New CInterpolation    ' результирующие точки для заполнения массивов
Private Sub Class_Initialize()
    ' установка значений по умолчанию
    wall_thickness_mm_ = 10
    wall_roughness_m_ = 0.0001
    length_between_points_m_ = 100     ' по умолчанию ставим расстояние между точками инклинометрии 100 м
    h_abs_init_m_.isStepFunction = False   ' абсолютные глубины линейно интерполируются
    angle_init_deg_.isStepFunction = True   ' углы - ступенчатая функция
    diam_init_m_.isStepFunction = True   ' диаметры - ступенчатая функция
End Sub
Public Sub init_from_curves(ByVal habs_curve_m As CInterpolation, _
                            ByVal diam_curve_mm As CInterpolation)
    Dim i As Integer
    Dim ang
    Dim sina As Double, cosa As Double
    
    angle_init_deg_.ClearPoints
    
    Set h_abs_init_m_ = habs_curve_m
    diam_curve_mm.isStepFunction = True
    Set diam_init_m_ = diam_curve_mm.transform(multY:=const_convert_mm_m)
    diam_init_m_.isStepFunction = True   ' диаметры - ступенчатая функция
        
    For i = 2 To habs_curve_m.num_points
       sina = (habs_curve_m.PointY(i) - habs_curve_m.PointY(i - 1)) / (habs_curve_m.pointX(i) - habs_curve_m.pointX(i - 1))
       cosa = Sqr(MaxReal(1 - sina ^ 2, 0))
       If cosa = 0 Then
           ang = 90 * sina
       Else
           ang = Atn(sina / cosa) * 180 / const_Pi
       End If
       angle_init_deg_.AddPoint habs_curve_m.pointX(i - 1), ang
    Next i
    calc_trajectory
End Sub
Private Function calc_trajectory() As Boolean
    ' функция расчета траектории скважины - из исходных данных считает нормализованные выходные данные и готовит данные для скважины
    Dim i As Integer
    Dim h As Double
    Dim allDone As Boolean
    Dim i_constrPoint As Integer
    Dim Hmes As Double, HmesNext As Double
    
    construction_points_curve_.ClearPoints
    construction_points_curve_.AddPoint 0, 0   ' на всякий случай добавим в конструкцию нулевую точку из которой стартуем
    For i = 1 To diam_init_m_.num_points
        h = diam_init_m_.pointX(i)
        construction_points_curve_.AddPoint h, h_abs_init_m_.getPoint(h)
    Next i
     
    Hmes = 0
    i = 0
    i_constrPoint = 1
    allDone = False
    
    ' начинаем цикл, в котором формируем набор точек из которых должна состоять траетория скважины
    ' учитывая минимальное расстояние между точками и присутствие в списке всех обязательных точек
    Do
       HmesNext = Hmes + length_between_points_m_    ' смотрим куда должна попасть след точка
       If construction_points_curve_.pointX(i_constrPoint) < HmesNext Then
           Hmes = construction_points_curve_.pointX(i_constrPoint)
           i_constrPoint = i_constrPoint + 1
       Else
           Hmes = HmesNext
       End If
    
       If Hmes >= construction_points_curve_.maxx Then
           Hmes = construction_points_curve_.maxx
           allDone = True
       End If
       h_points_curve_.AddPoint Hmes, h_abs_init_m_.getPoint(Hmes)   ' сохраняем измеренную и абсолютную глубины тут
    Loop Until allDone
    ' набор точек для траектории сформирован
    
    ' дальше надо по данному набору заполнить все элементы массива конструкции
    
    ReDim pipe_trajectory_(h_points_curve_.num_points - 1)
    For i = 0 To h_points_curve_.num_points - 1
       Hmes = h_points_curve_.pointX(i + 1)
       With pipe_trajectory_(i)
           .h_mes_m = Hmes
           .h_abs_m = h_points_curve_.PointY(i + 1)
           .ang_deg = angle_init_deg_.getPoint(Hmes)
           .diam_in_m = diam_init_m_.getPoint(Hmes)
           .diam_out_m = diam_init_m_.getPoint(Hmes) + wall_thickness_mm_ * const_convert_mm_m
           .roughness_m = wall_roughness_m_
       End With
    Next i
    
    ' траекторию сформировали
    ' надо теперь подготовить массивы для класса скважина
End Function
' функция для подготовки траектории с данных листа
' должна использоваться для чтения исходных данных с листа
' ожидаем, что на входе либо range - тогда их конвертируем в массивы
' либо массивы, либо числа - тогда генерируем простые массивы
Public Sub init_from_vert_range(ByRef h_data_m As Variant, _
                       Optional ByRef diam_data_mm As Variant)
' h_data_m - инклинометрия - range или двухмерный массив или число
'            зависимость значений вертикальной глубины от измеренной,
'            первый столбец - измеренная глубина, м
'            второй столбец - вертикальная глубина, м
'            если передано одно число - то будет задана вертикальная траектория заданной глубины
' diam_data_mm - значения диаметров от измеренной глубины - range или двухмерный массив или число
'            первый столбец - измеренная глубина, м
'            второй столбец - диаметр трубы, мм - применяется от текущего значения глубины и до следующего
'            если передано одно число - то будет задан постоянный диаметр
    Dim i As Integer
    Dim habs_curve_m As New CInterpolation
    Dim diam_curve_mm As New CInterpolation
    Dim diam_val_mm As Double, h_val As Double
    Dim diam_number As Boolean, h_number As Boolean
    Dim fix_index As Integer
    
    
    diam_number = False
    diam_val_mm = -1
    h_number = False
    h_val = -1
    ' проверим
    If TypeName(h_data_m) = "Range" Then h_data_m = h_data_m.value
    
    If IsNumeric(h_data_m) Then
        If h_data_m > 0 Then h_val = h_data_m
        h_number = True
    End If
    
    If h_val > 0 Then
        ReDim h_data_m(1 To 2, 1 To 2)
        h_data_m(1, 1) = 0
        h_data_m(2, 1) = h_val
        h_data_m(1, 2) = 0
        h_data_m(2, 2) = h_val
    End If
     
    For i = LBound(h_data_m) To UBound(h_data_m)
        If LBound(h_data_m) = 0 Then
            fix_index = -1
        Else
            fix_index = 0
        End If
        
        If Not (IsEmpty(h_data_m(i, 1 + fix_index)) Or IsEmpty(h_data_m(i, 2 + fix_index))) Then
            habs_curve_m.AddPoint h_data_m(i, 1 + fix_index), h_data_m(i, 2 + fix_index)
        Else
            h_data_m(i, 1) = h_data_m(i - 1, 1)
            h_data_m(i, 2) = h_data_m(i - 1, 2)
        End If
    Next i
    
    If TypeName(diam_data_mm) = "Range" Then diam_data_mm = diam_data_mm.value
    
    If IsNumeric(diam_data_mm) Then
        If diam_data_mm > 0 Then diam_val_mm = diam_data_mm
        diam_number = True
    End If
    
    
    If IsMissing(diam_data_mm) Then diam_val_mm = const_pipe_diam_default_mm
    If IsMissing(diam_data_mm) Or diam_val_mm > 0 Then
        ReDim diam_data_mm(1 To 2, 1 To 2)
        diam_data_mm(1, 1) = 0
        If h_number Then
           diam_data_mm(2, 1) = h_data_m
        Else
           diam_data_mm(2, 1) = h_data_m(UBound(h_data_m), 1)
        End If
        diam_data_mm(1, 2) = diam_val_mm
        diam_data_mm(2, 2) = diam_val_mm
    End If
    
    
    For i = LBound(diam_data_mm) To UBound(diam_data_mm)
        If LBound(diam_data_mm) = 0 Then
            fix_index = -1
        Else
            fix_index = 0
        End If
        If Not (IsEmpty(diam_data_mm(i, 1 + fix_index)) Or IsEmpty(diam_data_mm(i, 2 + fix_index))) Then
            diam_curve_mm.AddPoint diam_data_mm(i, 1 + fix_index), diam_data_mm(i, 2 + fix_index)
        End If
    Next i
    Call init_from_curves(habs_curve_m, diam_curve_mm)
End Sub
' ========================================================================
' свойства и методы задания параметров
' ========================================================================
Public Property Get num_points() As Integer
    num_points = h_points_curve_.num_points
End Property
Public Property Get ang_deg(i As Integer) As Double
    ang_deg = pipe_trajectory_(i).ang_deg
End Property
Public Property Get ang_hmes_deg(h_mes_m As Double) As Double
    ang_hmes_deg = angle_init_deg_.getPoint(h_mes_m)
End Property
Public Property Get h_mes_m(i As Integer) As Double
    h_mes_m = pipe_trajectory_(i).h_mes_m
End Property
Public Property Get h_abs_m(i As Integer) As Double
    h_abs_m = pipe_trajectory_(i).h_abs_m
End Property
Public Property Get h_abs_hmes_m(ByVal h_mes_m As Double) As Double
    h_abs_hmes_m = h_points_curve_.getPoint(h_mes_m)
End Property
Public Property Get diam_in_m(i As Integer) As Double
    diam_in_m = pipe_trajectory_(i).diam_in_m
End Property
Public Property Get diam_hmes_m(h_mes_m As Double) As Double
    diam_hmes_m = diam_init_m_.getPoint(h_mes_m)
End Property
Public Property Get roughness_m() As Double
    roughness_m = wall_roughness_m_
End Property
Public Property Let roughness_m(val As Double)
    Dim i As Integer
    If val > 0 Then wall_roughness_m_ = val
    For i = 0 To h_points_curve_.num_points - 1
        pipe_trajectory_(i).roughness_m = wall_roughness_m_
    Next i
End Property
Public Property Get wall_thickness_m() As Double
    wall_thickness_m = wall_roughness_m_
End Property
Public Property Let wall_thickness_mm(val As Double)
    Dim i As Integer
    Dim Hmes As Double
    If val > 0 Then wall_thickness_mm_ = val
    For i = 0 To h_points_curve_.num_points - 1
       Hmes = h_points_curve_.pointX(i + 1)
       With pipe_trajectory_(i)
           .diam_out_m = diam_init_m_.getPoint(Hmes) + wall_thickness_mm_ * const_convert_mm_m
       End With
    Next i
End Property
Public Property Get top_m() As Double
    top_m = h_points_curve_.pointX(1)
End Property
Public Property Get bottom_m() As Double
    bottom_m = h_points_curve_.pointX(num_points)
End Property

